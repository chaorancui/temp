
1. **两数之和：**hashTable（而unordered_set和unordered_map内部实现是基于哈希表(hashtable)）（O(n), O(1)）
2. 单链表ListNode只完成实现，没有操作方法实现
3. 滑动窗口（查询和增删元素），可借助基于HashTable的容器（C++11标准中unordered_set）
4. ？？
5. **最长回文子串：**动态规划（O(n<sup>2</sup>), O(n<sup>2</sup>)），中心扩展（O(n<sup>2</sup>), O(1)）
6. **Z字变换：**找规律，按行排序（O(n), O(n)）
7. **整数翻转：**%10，/10，溢出处理
8. **字符串转整数：**对第一个字符和溢出的处理（数字和字符溢出处理稍有不同）
9. **回文整数：**1 整数翻转，判断是否相等；2 转换成字符串再用中心扩展
10. **正则表达式匹配：**

11.**盛水最多容器：**头、尾双指针，小的往中间移动（原理要明白）

12.**整数转罗马数字：**1 暴力；2 贪心 + 哈希(key大到小排列，可使用两个数组)

13.**罗马数字转整数：**哈希表（unordered_map )，前一个字符大于后一个字符+，否则-

14.**最长公共前缀：**1垂直扫描（O(S), O(1)）S是所有字符串中字符总量之和；2 字典树（复杂了）

15.**三数之和：**排序(STL中sort为快速排序) + 双指针（O(n<sup>2</sup>), O(1)）考虑排序空间O(n)

16.**最接近的三数之和：**排序 + 双指针（O(n<sup>2</sup>), O(1)）

17.**电话号码的字母组合：**哈希表  + 回溯（无剪枝）（O(3<sup>M</sup>*4<sup>N</sup>), O(1)）递归用栈未知

18.**四数之和：**排序 + 双指针（O(n<sup>2</sup>), O(1)），需去重，可优化

19.**删除链表的倒数第N个节点：**1 一遍遍历，固定间距两个指针（O(n), O(1)）；2 两边遍历

20.**有效的括号：**左括号压栈，右括号出栈（还有特殊处理）（O(n), O(n)）

21.**合并两个有序链表：**1 2个迭代dummy（O(M+N), O(1)）；2 递归（O(M+N), O(M+N)）

22.**括号生成：**1 暴力搜索（O(n<sup>2n</sup>n), O(n)）n<sup>2n</sup>个序列，每个验证n；2 回溯（O($4^n \over \sqrt n$), O(n)）（不太好写回溯）

23.**合并K个排序列表：**1 K个迭代dummy（O(M+N), O(1)）；

24.

25.

26.**删除排序数组中的重复项：**1 遍历（O(n), O(1)）

27.**移除元素：**遍历数组（O(n), O(1)）

28.**实现strStr():**子串遍历 （O((N - L)L)，O(1)）

29.**两数相除：**2的次幂的泰勒展开(除数翻倍)（O(logN), O(1)）

30.**串联所有单词的子串：**滑动窗口优化的暴力法（O(n), O(1)）

31.**下一个排列：**1 暴力枚举比较（O(n！), O(1)）；2 右侧找a[i-1]>a[i]，a[i-1]交换并升序（O(n), O(1)）

32.**最长有效括号：**1 用栈（O(n), O(n)）（怎样标记有效括号段的长度和起始位置）；2 动态规划

33.**搜索旋转排序数组：**二分法变形（O(logn), O(1)）（一半一定有序）

34.**在排序数组中查找元素的第一个和最后一个位置：**1 线性扫描；2 二分左和右边界（O(logn), O(1)）

35.**搜索插入位置：**1 线性扫描（O(n), O(1)）；2二分查找左边界（O(logn), O(1)）

36.**有效的数独：**1 分3次遍历行、列、子数独；2  一次遍历行、列、子数独（O(1), O(1)）

37.**外观数列：**1.迭代，每次迭代用left，right作为指示器一次遍历；2 打表

38.**组合总数：**1.回溯(将组合转换为排序去重) + 剪枝

39.

40.



46.**全排列：**1. 回溯（判断是否已经使用：std::find/std::count，使用数组标记）（O($n*n!$), O($n*n!$)）

47.**全排列II：**1.回溯+同层去重（`if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue; `）

48.**旋转图像：**1.四矩形交换，后`a[i][j]`位置被前`a[n-1-j][i]`填充；2.顺时针90 = 垂直翻转 + 次对角线翻转

49.**字母异位词分组：**1.字母异位词排序后相等（O(NKlogK), O(NK)）

50.**pow(x,n):**1.乘方转对数 $x^n = e^{nlnx}$ （O(1), O(1)）；2.分治思想

51.**N皇后：**1.回溯(只需按列循环|皇后约束isValid中)（O($n!$), O($n^2$)）2.约束编程+回溯()；

52.**N皇后II：**1.

53.**最大子序和：**1.动态规划+max(dp[i])（O(n), O(1)）;2.分治(线段树)（参见递归排序）

54.**螺旋矩阵：**1.按层模拟(外层-->内层)    O(mn), O(1)）

55.**跳跃游戏：**1.维护最远可跳位置O(n), O(1)）

56.**合并区间：**1.左端点排序 + 双指针（O(1), O(1)）

57.**插入区间：**1.贪心算法（O(n), O(n)）(每一步最佳 --> 全局最佳)（逻辑参见解答）

58.**最后一个单词长度：**1.从后向前索引（O(1), O(1)）

59.**螺旋矩阵II：**1.参见54

60.**第K个排列：**1.DFS+阶乘剪枝；2.除法、取余定位（O(n), O(1)）【31/46/47/60/题解收藏：排列组合第K个】

61.**旋转链表：**1.链表成环（O(n), O(1)）

62.**不同路径：**1.排列组合（O(n), O(1)）；2.动态规划(当前步数=左步数+上步数)（O(mn), O(mn)）3.递归

63.**不同路径II：**1.动态规划(当前步数=左步数+上步数, 障碍物步数=0)（O(mn), O(mn)）

64.**最小路径和：**1.动态规划(当前总和=min(左总和+上总和)+当前值)（O(mn), O(mn)）

65.**有效数字：**1.分段判断 A.B[e/E]C（O(n), O(1)）

66.**加一：**1.竖式计算carry（O(n), O(1)）

67.**二进制求和：**1.竖式计算carry（O(m+n), O(1)）

68.**文本左右对齐：**1.拿一行放一行

69.**x的平方根：**1.暴力搜索；2.二分法搜索；3.牛顿迭代(判断条件可以不用误差阈值)

70.**爬楼梯：**1.回溯（O($2^n$), O(n)）；2.动态规划（O(n), O(n)）；3斐波那契数列（O(n), O(1)）

71.**简化路径：**1.istringstream 和 getline 分割字符串

72.**编辑距离：**1.二维动态规划

73.**矩阵置零：**1.首行首列标记（O(mn), O(1)）

74.**搜索二维矩阵：**1.行列转换，标准二分（O(log(mn)), O(1)）；2.定位行二分，行中二分（O(logm+logn), O(1)）

75.**颜色分类(荷兰国旗)：**1.三指针（O(n), O(1)）（注意cur <= hi）；2.计数排序（O(n+k),O(n+k)）

76.**最小覆盖子串：**1.

77.**组合：**1.回溯 （无重复元素 + 单次选取 ，下层递归start后移一位，start = CurIndex + 1）

78.**子集：**1.上题k = 0-n或一遍递归直接加入ans；2.字典排序（二进制排序） 子集

79.**单词搜索：**1.二维回溯 + 及时掐断（设置方向偏移量）

80.**删除排序数组中的重复项II：**1.双指针（逻辑参考官解）（O(n), O(1)）

81.**搜索旋转排序数组II：**1.改进二分法（一般有序 + lo++）33题

82.**删除链表中重复元素II：**1.双指针 + count计数（双指针 + 指针是否相邻，尾部处理）（O(n), O(1)）

83.**删除链表中重复元素：**1.双指针（尾部处理）（O(n), O(1)）

84.**分隔链表：**1.双链表尾插法 + 合并；2.插中间符合要求后（麻烦，不建议）3.>x元素尾插法（均为O(n), O(1)）

85.

86.

87.**扰乱字符串：**1.

88.**合并两个有序数组：**1.

89.**格雷编码：**1.数学找规律（除最高位对称）2.二进制转格雷码（i ^ (i>>1)）（O($2^n$), O(1)）

90.**子集II：**1.回溯 + 同层去重 + 排序

91.**解码方法：**1.动态规划 （dp[i] 为 string[0...i] 译码方法总数）（O(n), O(1)）

92.**翻转链表II：**1.双指针就地翻转链表（O(n), O(1)）

93.

94.**二叉树的中序遍历：**1.递归；2.用栈（参见编程技巧）

95.**不同的二叉搜索树II：**1.递归生成左右子树，各挑一棵组合

96.**不同的二叉搜索树：**1.95计数；2.数学公式（卡塔兰数，见官方）

97.

98.**验证二叉搜索树：**1.递归（上下界）（O(n), O(n)）；2.中序遍历有序（O(n), O(n)）

99.

100.**相同的树：**1.递归判断（返回条件及返回值）

101.**对称二叉树：**1.递归左右子树；2.迭代左右子树（借助队列）

102.**二叉树的层序遍历：**1.BFS搜索（借助队列）

103.**二叉树的锯齿形层序遍历：**1.BFS搜索（标志位+双端队列/或翻转vector）

104.



111.**二叉树的最小深度：**1.BFS搜索（借助队列）；2.递归求最小高度=最小深度



125.**验证回文串：**1.筛选+双指针/翻转（O(n), O(1)）



136.**只出现一次的数字**：1.异或（O(n), O(1)）

137.**只出现一次的数字II**：1.逻辑电路状态转换，模3运算(可扩展到出现n次)（O(n), O(1)）



169.**多数元素**：1.摩尔投票法（O(n), O(1)）（抵消阶段和计数阶段）



198.**打家劫舍：**1.动态规划（O(n), O(1)）



215.**数组中的第K个最大元素**：1.改进quicksort（O(n), O(logn)）2.STLsort/小根堆

226.**翻转二叉树**：1.递归翻转每个节点

229.**求众数**：1.摩尔投票法（O(n), O(1)）

234.**回文链表**：1.快慢指针，翻转链表前半部分

240.**搜索二维矩阵**：1.从左下查找，右增上减O(n),O(1)



239:**滑动窗口最大值：**1.单调栈/队列(可借助stack/queue/deque/list实现)（O(n), O(k)）



300.**最长上升子序列**：1.动态规划(第i个数字结尾的最长上升子序列) (O($n^2$),O(n))

338.**比特位计数：**1.从二进制找规律：奇 = 偶 + 1，偶 = 偶 / 2；（O(n), O(n)）

347.**前K个高频元素：**1.HashMap+HeapSort(小顶堆)；（O(nlogn), O(n)）

406.**根据身高重建队列：**1.自定义sort排序+贪心算法（高个子先插入）（O($n^2$), O(n)）



729.**每日温度：**1.暴力搜索；2.单调栈(递减栈)（O(n), O(n)）(在当前元素后边中搜索)

