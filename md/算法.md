### 动态规划

**动态规划一定要明确 `dp` 数组的含义。** 

* **将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解**。

* 空间换时间，将计算结果暂存起来，避免重复计算

* 动态规划关键是找到**初始状态**和**状态转移方程**。

###### 实现方式：①**自顶向下的备忘录法** ②**自底向上。**

* 备忘录方法，采用的是**自顶向下**的思想，但是该方法维护了一个记录子问题解的表，虽然填表动作的控制结构更像递归方法，但是的确避免了子问题的重复求解。

* 动态规划的基本思想是，将原问题拆分为若干子问题，**自底向上**的求解。其总是充分利用重叠子问题，即通过每个子问题只解一次，把解保存在一个表中，巧妙的避免了子问题的重复求解。

###### 例子：**Fibonacci** 数列 Fn = Fn-1 + Fn-2

### 贪心算法

所谓贪心算法是指，在对问题求解时，总是**做出在当前看来是最好的选择**。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的**局部最优解**。

###### 例子：纸币找零问题

### 递归、回溯、DFS

* 为了描述问题的某一状态，必须用到该状态的上一状态，而描述上一状态，又必须用到上一状态的上一状态……这种用自已来定义自己的方法，称为**递归**定义。形式如 f(n) = n*f(n-1), if n=0,f(n)=1.

* 从问题的某一种可能出发, 搜索从这种情况出发所能达到的所有可能, 当这一条路走到” 尽头 “的时候, 再倒回出发点, 从另一个可能出发, 继续搜索. 这种不断” 回溯 “寻找解的方法, 称作” **回溯法** “。

* **递归是一种算法结构**，递归会出现在子程序中自己调用自己或间接地自己调用自己。最直接的递归应用就是计算连续数的阶乘，计算规律：n!=(n-1)!*n。**回溯核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**，特别简单。

* **回溯是一种算法思想**，可以用递归实现。通俗点讲回溯就是一种试探，**类似于穷举，但回溯有“剪枝”功能**，比如求和问题。给定7个数字，1 2 3 4 5 6 7求和等于7的组合，从小到大搜索，选择1+2+3+4 =10>7，已经超过了7，之后的5 6 7就没必要在继续了，这就是一种搜索过程的优化。如果还有不清楚的可以看一下8皇后问题。

* 回溯搜索是**深度优先搜索（DFS）的一种**。对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，**回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。**

* 回溯算法和递归紧密的联系，而递归和栈有紧密关联。我们可以将递归看做**一次次入栈出栈**的过程，对于回溯算法则是一种参考**二叉树的遍历**过程中的产生的算法处理方式。在二叉树使用遍历的处理也同样用到了递归和回溯的深度优先dfs的处理方案。

  ###### 递归例子：阶乘计算n!=(n-1)!*n

  ```C++
      int factorial(int n) {
          if (n == 0)		// 这里最好写0
              return 1;
          else
              return n * factorial(n - 1);
      
  ```

  ###### 回溯例子：全排列，8皇后

  ```python
  # 回溯算法的框架：
  result = []
  def backtrack(路径, 选择列表):    # 路径多为树的层数索引，可用int型
      if 满足结束条件:
          result.add(路径)
          return
  
      for 选择 in 选择列表:    # 横向遍历解答树所有子节点
          做选择
          backtrack(路径, 选择列表)
          撤销选择
  '''
  1、路径：也就是已经做出的选择。(树的层数索引)
  2、选择列表：也就是你当前可以做的选择。(每层的遍历)
  3、结束条件：也就是到达决策树底层，无法再做选择的条件。
  做选择和撤销选择：
      * 0/1标记是否已选择；
      * 树从左至右(树的遍历)；(无剪枝情况)
      * 使用if + continue排除不合法选择；
  '''
  ```

   **递归的方法相当于深度遍历，队列的方法相当于广度遍历，两者都很重要。**

  - **DFS**: `Depth First Search` 深度优先搜索，简称深搜
  - **BFS**：`Breadth First Search` 广度优先搜索，简称广搜

### BFS

BFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。主要应用于求解迷宫、最短路径、最短步数问题。

```c++
  // BFS算法的框架：
  // 计算从起点 start 到终点 target 的最近距离
  int BFS(Node start, Node target) {
      Queue<Node> q; // 核心数据结构
      Set<Node> visited; // 避免走回头路
  
      q.offer(start); // 将起点加入队列
      visited.add(start);
      int step = 0; // 记录扩散的步数
  
      while (q not empty) {
          int sz = q.size();
          /* 将当前队列中的所有节点向四周扩散 */
          for (int i = 0; i < sz; i++) {
              Node cur = q.poll();// 获取并移除队列头
              /* 划重点：这里判断是否到达终点 */
              if (cur is target)
                  return step;
              /* 将 cur 的相邻节点加入队列 */
              for (Node x : cur.adj())
                  if (x not in visited) {
                      q.offer(x);
                      visited.add(x);
                  }
          }
          /* 划重点：更新步数在这里 */
          step++;
      }
  }
  一般也会设置一些visited[] 来记录元素访问与否，做剪枝，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要visited。
```

  

  ### 哈弗曼树

  哈弗曼树又叫做最优二叉树，是权值越大的点离根节点越近，导致整个树权值最小

  方法：选择值最小的两个点作为左右节点，然后和作为父节点，在剩下的点以及父节点中选择最小的两个依次构造，形成哈弗曼树。**左边数值是0，右边是1。**

  哈弗曼编码是将各个点的值加起来最小

  例a(3), b(2), l(1), i(1)

  ​				7

  ​			0/	\1

  ​			4		a(3)

  ​		0/	\1

  ​		2		b(2)

  0/	 \1

  L(1)	i(1)

  a:1;

  b:01;

  i :001;

  L:000;

  长度计算就是把各个点的值乘以路径长加起来，即 $1*3+1*3+2*2+1*3 = 13$ 

  ### 排序

  在待排序的元素序列基本有序的前提下，效率最高的排序方法是插入排序。

  快速排序是平均性能最好的排序算法，数据规模越大快速排序的性能越优。快排在极端情况下会退化成O($n^2$)的算法（每次划分所取的基准总是数组中最小的）

  ### 由遍历顺序写二叉树

  由 先序序列 + 中序序列  可以唯一地确定一棵二叉树；

  由 中序序列 + 后序序列 也可以唯一地确定一棵二叉树。

  ```markdown
  先序：考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)
  
  中序：考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)
  
  后序：考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)
  
  
  先序特点：根结点位于先序序列的最前
  后序特点：根结点位于后序序列的最后
  中序特点：根结点将中序序列分割为左子树序列和右子树序列两个部分。
  
  中序 + 后序为例：
  后序获得根节点，中序将树分为左子树和右子树。分别对左子树和右子树分别进行上述操作，递归下去，即可构造出二叉树。
  
  例如给定结点的中序序列(D,B,G,E,A,C,F)和后序序列(D,G,E,B,F,C,A),则可以唯一确定一颗二叉树：
  由后序序列，A是二叉树的根结点，再根据中序序列得知，A的左子树中序序列为(Ｄ,B,G,E)，右子树中序序列为(C,F)。然后在后序序列中，可以确定A的左子树后序序列为(D,G,E,B)，右子树后续序列为(F,C)。进一步，由A的左子树后续序列得知，B是子树(D,G,E)的根结点，由中序序列(D,B,G,E)知道，B的左子树是D，右子树中序序列是(G,E)，而后序序列是(G,E)。子树(G,E)的根结点为E，从而左子树为G。因此，确定了A的左子树，同理，可以确定A的右子树。
  ```

### 分块查找

分块查找表：块间（索引表）有序，块内无需。

### 红黑树和AVL树

红黑树和AVL树都是自平衡二叉树。AVL树是完全平衡二叉树，且左右子树都是AVL二叉树，每个节点高度差不大于1.红黑树不追求完全平衡，从而降低旋转的次数。







