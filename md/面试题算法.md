[TOC]



# C/C++基础概念

## malloc和new的不同

还记得经典面试题吗：比较一下malloc和new的不同。这个问题其实不难，首先明确：

1. **malloc是标准库函数，而new是关键字**。
2. 然后new作为C++中动态创建对象时，除了完成堆空间的分配操作以外还要完成一些初始化操作，及**new的过程中会调用对象的构造函数去初始化，而malloc不会**。例如new一个vector，会调用vector构造函数。
3. malloc需要自己计算类型的大小且返回值为void*，new自动计算类型的大小，返回值为对应类型的指针。
4. 最后要明确的是**malloc分配的内存只能用free来释放，而new分配的地址只能用delete来释放，如果new分配的是数组，则需要delete[ ]来释放**，否则会出现未定义行为。（delete后指向空是一个好习惯）

无论是malloc还是new**返回的都是一个指针，即堆地址**。堆与栈不同它不是顺序分配的，而是**离散分配**的，它的空闲内存可能不是连续的，而是断断续续的，通常通过**链表来连接**每个空闲存储区（实际数据结构要更复杂和多样化）



## 引用与指针有什么区别

指针是一个变量，指向一块内存；引用是某块内存的别名。

1. 引用在定义时就需被初始化，且之后不能被改变指向，指针可以不初始化，且可以改变所指的对象。
2. 引用不可以为空，但指针可以为空。
3. 指针和引用的自增(++)运算意义不一样，指针是对内存地址的自增，引用是对变量值的自增；
4. 对引用使用“sizeof”得到的是变量的大小，对指针使用“sizeof”得到的是变量的地址的大小



## C++的class和struct区别

C++中，struct和class有很多相同的地方：都可以包含成员函数、都可以继承和实现多态。

他们最大的区别在于默认的访问权限和继承权限不同：class默认的访问和继承权限是private,strcut默认的访问和继承权限是public。

此外，在模板类声明中，“class”关键字还用于定义模板参数，和“typename”通用，但struct不行。

```C++
1 template < class T>
2 template < typename T>
```

还有在用{}初始化的时候也有区别：若都定义了构造函数，都不能用{}初始化；若未定义构造函数，struct可以用{}初始化，若类的所有成员变零都是public，可以用{}初始化。

C中的struct功能较少，只有封装数据的功能，不能继承，也不能包含成员函数。



## 空类的大小为什么是1

C++标准禁止对象大小为 0，因为两个不同的对象需要不同的地址表示

实际上，这是类结构体实例化的原因，空的类或结构体同样可以被实例化，如果定义对空的类或者结构体取sizeof()的值为0，那么该空的类或结构体实例化出很多实例时，在内存地址上就不能区分该类实例化出的实例，，，所以，为了实现每个实例在内存中都有一个独一无二的地址，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。



## 重写memcpy()函数需要注意哪些问题

主要考虑地址重叠的问题。更具体来说是从前往后拷贝还是从后往前拷贝。举个例子，

1）源地址是arr[2]，目标地址是arr[0],自前向后拷贝3个元素后arr为{3,4,5,4,5}

2）源地址是arr[0]，目标地址是arr[2],自前向后拷贝3个元素后arr为{1,2,1,2,3}

第一种情况，由低地址向高地址逐个将源地址的元素拷贝到目标地址就行，容易；

第二种情况需要注意，如果是按第一种情况由低地址拷贝到高地址，需要分3个步骤把arr[0]=1,arr[1]=2,arr[2]=3三个元素逐个拷贝，重点在于第一步是将arr[0]拷贝到arr[2]的位置，这样就会把原来的arr[2]=3改为arr[2]=1，覆盖了原来的值，因此在这种情况，我们需要自后向前拷贝，也就是高地址向低地址拷贝。也就是第一步将arr[2]放到arr[4],第二步将arr[1]放到arr[3],第一步将arr[0]放到arr[2].



## static的用法

static用法有两个：改变生命周期和改变作用域

局部变量：被声明为static时，其再函数执行完成后不会立即释放，而是一直保留在内存中。但其只在定义它的函数中可见。

全局变量：本身就是静态变量，从变量定义到程序结束一直存在。被声明为static时，会改变其作用域，使其仅在本文件中有效，在外部文件中不可用。

函数：被声明为static时，使得函数的作用域改变，仅在本文件中有效，对其他文件不可见。

在C++类中：

当成员变量或成员函数被声明为static时，被类的所有对象所共有，可直接通过类名访问。



## const用法

const主要用来修饰变量、函数形参和类成员函数：

1）变量：表示变量的值不可修改，且在定义时就要进行初始化。

2）函数形参：表示形参在函数里不可修改。

3）类成员函数：表明该成员函数只能读取成员变量而不能进行修改。



## const常量和#define的区别（编译阶段、安全性、内存占用等）

1. const 常量有数据类型，而宏定义没有数据类型。
2.  \#define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。
3. const常量可以进行调试的，define是不能进行调试的。
4. 编译器对const会进行类型安全检查，而宏定义只是简单地代码替换，可能出现意想不到的错误。



## volatile作用和用法

寄存器的访问要比访问内存单元快的多,所以编译器一般都会对变量进行优化，以减少操作内存次数。volatile是告诉编译器该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错。



## 有常量指针 指针常量 常量引用 没有 引用常量

后面两个字代表这是个什么东东，前面两个字代表这个是什么类型：

（1）常量指针：也叫常指针，最后两个字是“指针”，代表这是一个指针，但指向的是一个常量，

```C++
int a = 0;
const int *p = &a; //不可以通过p改变a
```

（2）指针常量：后面两个字是“常量”，代表这是个常量，不过是指针类型的常量，

```C++
int a = 0;
int* const p = &a;  //从后往前看，这是个指针常量，指向的a的值可以改变，但p本身不可改变
```

有一个规则可以很好的区分const是修饰指针，还是修饰指针指向的数据——画一条垂直穿过指针声明的星号（*），如果const出现在线的左边，指针指向的数据为常量；如果const出现在右边，指针本身为常量。而引用本身与天俱来就是常量，即不可以改变指向。

```C++
const int *p = &a //从后往前看，const修饰的是*p，所以指针p指向的数值不可变
int *const p = &a; //从后往前看，const修饰的是p，所以指针p本身不可变
```

（3）常量引用：后两个字是“引用”，那么这个是引用，并且是常量的引用，那么就有两个性质，如下：

```C++
double a;
const int &r = a; //正确 性质1：不可通过常量引用r来改变a
const int &r = 10;//正确 性质2：常量引用可以直接引用具体数值
```

（4）没有引用常量：后面两个字代表这个是常量，前面代表这个是引用类型的常量，然而常量就是常量了，并没有引用类型的常量。



##  c++中类型转换机制？各适用什么环境？dynamic_cast转换失败时，会出现什么情况？（对指针，返回NULL,对引用，抛出bad_cast异常）

（1）static_cast

特点：静态转换，在编译时发生。

应用场合：主要用于C++中内置的基本数据类型之间的转换，但是没有运行时类型的检测来保证转换的安全性。

 用于基类和子类之间的指针或引用之间的转换，这种转换把子类的指针或引用转换为基类表示是安全的；进行下行转换，把基类的指针或引用转换为子类表示时，由于没有进行动态类型检测，所以是不安全的。上行安全下行不安全

 把void类型的指针转换成目标类型的指针（不安全）。

 不能用于两个不相关的类型转换。

 不能把const对象转换成非const对象。

（2）const_cast

特点：去常转换，发生在编译时。不是运行时

应用场合：const_cast操作不能在不同的种类间转换。相反，它仅仅把它作用的表达式转换成常量。它可以使一个本来不是const类型的数据转换成const类型的，或者把const属性去掉。 

去掉const属性：const_case<int*> (&num)，常用，因为**不能把一个const指针和引用直接赋给一个非const指针和引用，必须要转换。** 

const_case只能转换**指针或引用** ，不能转换变量

（3）reinterpret_cast

特点： 重解释类型转换，在编译时发生

应用场合：它有着和c风格强制类型转换同样的功能；它可以转化任何的内置数据类型为其他的类型，同时它也可以把任何类型的指针转化为其他的类型；它的机理是对二进制进行重新的解释，不会改变原来的格式。

（4）dynamic_cast <type-id **> (** expression **)**

动态转换，在运行时发生

主要用于类之间的上下行之间的转换。上行转换时和static_cast效果一样，下行转换时，具有检测功能，比static_cast更安全。

将一个指向基类的指针转换成指向派生类的指针；如果失败，返回空指针。



## 内联函数

当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用. 

一个较为合理的经验准则是, 不要内联超过 10 行的函数. 

有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 




## C++编译程序流程：

分为4步： 

  1、预处理：头文件展开、宏定义展开、条件编译等，不做语法检查 

  2、编译：检查语法，将预处理后文件编译生成汇编文件

  3、汇编：将汇编文件生成目标文件(二进制文件) 

   4、链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去



## 内存溢出和内存泄漏

**内存泄漏（memory leak）：** 

是指程序在申请内存后，却没有释放已申请的内存空间，导致该内存一直被占用，无法被其他程序使用。简而言之：调用了malloc/new等申请内存的操作，但是缺少了对应的free/delete操作。

**以发生的方式来分类，内存泄漏可以分为4类：**

1. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。

2. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。

3. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。

4. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。

**内存溢出：** 

是指程序要求分配的内存超出了系统所能给的。产生原因：
（1）内存中加载的数据量过于庞大，如一次性从数据库取出过多数据。 
（2）代码中存在死循环或循环产生过多重复的对象实体。 
（3） 集合类中有对对象的引用，使用后未清空，使得不能回收。
（4）使用的第三方软件中的bug （5）启动参数内存值设定的过小

**内存越界：** 

是指向系统申请一块内存后，**使用时**却超出申请范围。比如一些操作内存的函数：sprintf、**strcpy**、strcat、vsprintf、**memcpy**、**memset**、memmove。当造成内存泄漏的代码运行时，所带来的错误是无法避免的，通常会造成
1.破坏了堆中内存内存分配信息数据
2.破坏了程序其他对象的内存空间
3.破坏了空闲内存块	

注意：内存越界跟内存溢出的区别，前者是在使用系统提供的内存时，做了一些超出申请的内存范围的操作；而后者则是在申请内存大小时就已超出系统能提供的。




# 继承、多态相关面试题

## 被隐藏的基类函数如何调用或者子类调用父类的同名函数和父类成员变量

1）用using关键字：使用using后，父类的同名函数就不再隐藏，可以直接调用，如下：

```C++
class Child:public Parent
{
public:
    Child(){};
    using Parent::add;
    int add(void){};
};
```

2）用域操作符，可以调用基类中被隐藏的所有成员函数和变量。

如子类child和父类father都有add（）函数，可以通过下面代码实现子类对象调用父类的add（）函数：

```C++
Child c;
c.Parent::add(10);
```



## C++如何实现多态

C++实现多态需要满足三个条件

1. 要有虚函数

2. 要有继承

3. 要有父类指针指向子类对象

编译器发现类中有虚函数时，会生成类的虚函数表vtable，虚函数表里边是指向虚函数的指针。另外，包含虚函数的类对象中还包含虚指针用来指向虚表。父类对象指针指向子类对象时，其虚指针便会指向子类的虚表，这样就可以调用子类的虚函数，实现动态调用。



## 浅拷贝、深拷贝、什么时候需要自定义拷贝构造函数？

浅拷贝是增加了一个指针，指向原来已经存在的内存。浅拷贝会使多个对象指向一块内存。然而当内存销毁的时候，指向这个内存空间的所有指针需要重新定义,不然会造成野指针错误。

深拷贝指拷贝对象的具体内容,其内容地址是自助分配的,拷贝结束之后,内存中的值是完全相同的,但是内存地址是不一样的,两个对象之间相互不影响,也互不干涉.

就像影子和克隆人的区别。

默认拷贝构造函数执行的是浅拷贝，当类中动态分配成员或包含指针成员的类都应该提供拷贝构造函数；在提供拷贝构造函数的同时，还应该考虑重载"="赋值操作符号。



## 构造函数为什么不能声明为虚函数

1.在构造一个对象的时候，必须知道对象的确切类型，是基类还是派生类或者更深层次的派生类，才能创建对象。而虚函数的运行依赖于虚函数表，它是在对象被构造之后才有的。和构造函数的作用相矛盾。



## 析构函数为什么通常声明为虚函数

如果析构函数不是虚函数，当要销毁基类指针指向的派生类对象时， delete函数只调用基类的析构函数，未调用派生类的析构函数，这样就会造成内存泄漏。



## 函数重载、重写（覆盖）、重定义（隐藏）

**函数重载**：（类中，函数名相同，参数列表不同）

是指多个函数函数名相同而参数列表不同（类型、个数、顺序），发生在同一个作用域中。
重载时在编译期间就确定了，根据不同的参数列表修饰函数名，决定函数调用。因此，重载和多态无关！
注意，子类无法重载父类的函数，父类同名函数将被名称覆盖。

**函数重写**：（类间的虚函数，函数名及参数列表相同，也称为覆盖，）：

是指子类重写父类中的虚函数，要求父类与子类中的函数原型必须完全相同。
重写在运行期间确定，根据父类指针具体指向的类型来确定到底是调用父类中的函数还是子类中的函数。
注意：必须发生于父类与子类之间

**函数重定义**：（类间非虚函数，函数名相同，参数列表可相同也可不同，也称为隐藏）

如果在父类中定义一个非虚函数，（原理上子类会继承父类的函数），如果子类中有相同函数名（参数个数或类型与父类不同），本来是相当于重载的，但因为子类无法重载父类的函数，所以此时会出现名称覆盖。即打算用子类对象调用父类的该函数时会出现编译器报错。



## 什么是纯虚函数

纯虚函数声明：virtual 函数返回类型 函数名（参数表列）= 0；

纯虚函数在基类中只有声明没有定义，其定义在继承的子类中实现，定义了纯虚函数的类叫抽象类，为了实现接口作用。



# 计算机内存、硬件底层

## 大端序小端序

字节存储顺序主要分为`大端序`（Big-endian）和`小端序`（Little-endian），区别如下

- Big-endian：**高位**字节存入**低地址**，**低位**字节存入**高地址**
- Little-endian：**低位**字节存入**低地址**，**高位**字节存入**高地址**

端序是与硬件的体系结构相关而与所使用的操作系统无关的概念，目前基本上所有x86系列的PC机都是`Little-endian`字节序，PowerPC通常是`Big-endian`字节序。

判定方法：
方法一：将整形int强制转换char测试

```C++
bool isBigEndian() {
    int a = 1;
    if (((char*)&a)[sizeof(int) - 1] == 1) {
        return true;
    } else {
        return false;
    }
}
```

方法二：使用union，其所有成员共享同一个最大的内存地址。

```C++
bool isBigEndian() {
    union c {
        int a;
        char b;
    };
    c.a = 1;
    if (c.b == 1) {
        return true;
    } else {
        return false;
    }
}
```



## C/C++内存分布

**c语言：** 
**1）程序代码区：** 
代码段是用来存放可执行文件的操作指令，它是可执行程序在内存中的映像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。
**2）全局区/静态区（包括数据段和BSS段）：**
存放全局变量、静态变量。程序结束后由系统释放。
Ｃ程序根据全局变量和静态变量有没有进行显式初始化，还将它们分为两个不同的区域，即BSS和DATA。据说这种区别在C++中已经没有了，而且编码规范要求我们在定义一个变量时，一定要同时对它进行初始化（尤其是一个指针，最好将它置为空），所以我们尽量还是在允许的情况下，遵守这一规范。另外需要特别说明的是，当没有进行显式初始化时，它们的值将被初始化为０。
当函数或外部变量的前面冠以static时，它们的可见范围将限定在所在文件内，程序中其他文件无法见到它们，我们可以用这个办法来有效避免命名冲突。而当一个局部变量被static修饰时，它的可见范围并没有修改，还是限定在函数内，但它的生存期将延长为程序生存期，因为存储区域不是栈区，所以不会因为退栈而被销毁。
1、数据段：
存放可执行文件中已经初始化的全局变量，静态变量
2、BSS段：
包含了程序中未初始化的全局变量，在内存中全部置零

**3）堆区：**
由程序员通过malloc()等函数分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式类似于链表，堆是用于存放进程运行中被动态分配的内存段，它大小并不固定，可动态扩张或缩减。当进程调用malloc/new等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。
需要注意的有五点：
第一， 分配后马上进行分配成功与否的验证。
第二， 有分配必须有释放，否则将有可能造成内存泄露。遵循“谁分配谁释放”的原则。
第三， 操作上，malloc和free对应，new和delete对应。另外，前者是库函数，使用时需要加载相应头文件，后者是C++中的关键字，是运算符，不需要加特别的头文件。
第四， 运行效率没有栈高，而且大量频繁使用将造成更多的内存碎片。
第五， 虽然free()函数的参数是指针，但它释放的是内存而不是指针，所以当执行完free()操作后，还应该将指针置空，以避免野指针问题。

**4）栈区：**
存放局部变量、函数参数、返回数据、返回地址等。系统自动分配释放 ，其操作方式类似于数据结构中的栈。
栈中存放的是一个个被调函数所对应的堆栈帧，当函数fun1被调用，则fun1的堆栈帧入栈，fun1返回时，fun1的堆栈帧出栈。什么是堆栈帧呢，堆栈帧其实就是保存被调函数返回时下一条执行指令的指针、主调函数的堆栈帧的指针、主调函数传递给被调函数的实参(如果有的话)、被调函数的局部变量等信息的一个结构。

**c++：** 
在C++中，**内存分成5个区，**他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

1）**栈区** 

就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。

**2）堆区** 

就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

**3）全局/静态存储区** 

全局变量和静态变量被分配到同一块内存中，**在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，**他们共同占用同一块内存区。

**4）文字常量区** 

这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多，在《const的思考》一文中，我给出了6种方法）

**5）程序代码区** 

存放函数体的二进制代码。

```C++
//main.cpp
int a = 0;  //全局初始化区
char *p1;   //全局未初始化区
main() {
    int b;                // 栈
    char s[] = "abc";     // 栈
    char *p2;             // 栈
    char *p3 = "123456";  // 123456\0在常量区，p3在栈上。 static int c = 0； 全局（静态）初始化区
    p1 = (char *)malloc(10);
    p2 = (char *)malloc(20);  // 分配得来得10和20字节的区域就在堆区。
    strcpy(p1, "123456");     // 123456\0放在常量区，编译器可能会将它与p3所指向的 "123456" 优化成一个地方。
}
```



**堆和栈的主要区别：** 

　　主要的区别由以下几点：

　　1、管理方式不同；

　　2、空间大小不同；

　　3、能否产生碎片不同；

　　4、生长方向不同；

　　5、分配方式不同；

　　6、分配效率不同；

　　管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。

　　空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：

　　打开工程，依次操作菜单如下：Project->Setting->Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。

　　注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。

　　碎片问题：对于堆来讲，**频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。**对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。

　　生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。

　　分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。（alloca是在栈(stack)上申请空间,用完马上就释放.）

　　分配效率：**栈是机器系统提供的数据结构，计算机会在底层对栈提供支持**：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。**堆则是C/C++函数库提供的**，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

　　从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，**我们推荐大家尽量用栈，而不是用堆。**

　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。

　　无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候debug可是相当困难的：）







---

# 网络编程

## TCP与UDP区别总结：

 1、TCP面向连接（发送数据之前需要建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
 2、TCP提供可靠的服务。它能保证传输的数据无差错，不丢失，不重复，且按序到达;UDP尽最大努力传输，即不保证传输的顺序和正确性。
 3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是基于数据报的。
 4、TCP仅支持点到点的通信 ;UDP支持一对一，一对多，多对一和多对多的交互通信
 5、TCP要求系统资源较多，UDP较少； （TCP首部开销20字节;UDP的首部只有8个字节）
 6、TCP有流量控制，拥塞控制等功能；UDP没有；

拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。
流量控制：流量控制是为了解决发送方和接收方速度不同而导致的数据丢失问题,当发送方发送的太快,接收方来不及接受就会导致数据丢失。流量控制用滑动窗口的形式解决问题。



## TCP和UDP场景

TCP场景：对网络质量要求较高的场景，比如HTTP，FTP、SMTP等协议。

UDP场景：对网络质量要求较不高的场景，但对传输的数据量和实时性较高的场景，实时视频会议、直播，网络消息大多为短消息。



## 典型网络模型，简单说说有哪些

TCP/IP四层模型；  OSI七层模型、

应用层				应用层

​							表示层

​							会话层

传输层				传输层

网络层				网络层

链路层				数据链路层

​							物理层





## 三次握手：

1. 客户端向服务器端请求连接

2. 服务器端响应客户端，并向客户端发送连接请求

3. 客户端响应服务器端的连接请求----> 连接成功



## 四次挥手（两个方向都要单独关闭造成的）：中断连接的可以是客户端也可以是服务器端

1. 客户端向服务器端发送中断连接请求

2. 服务器端响应客户端连接中断请求，客户端等待服务器端FIN报文

3. 服务器没有数据要发送后，向客户端发送中断连接请求

4. 客户端响应服务器端的请求----> 关闭连接成功

服务器端先初始化Socket，然后与端⼝绑定(bind)，对端⼝进⾏监听(listen)，调⽤accept阻塞，等待客⼾端连接。在这时如果有个客⼾端初始化⼀个Socket，然后连接服务器(connect)，如果连接成功，这时客⼾端与服务器端的连接就建⽴了。客⼾端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客⼾端，客⼾端读取数据，最后关闭连接，⼀次交互结束。


```C++
/*
 * Client */
int   sockfd, n;
struct sockaddr_in  servaddr;
char  recvline[4096], sendline[4096];

if ( argc != 2) {
    printf("usage: ./client <ipaddress>\n");
    return 0;
}
if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){// 初始化socket
    printf("create socket error: %s(errno: %d)\n", strerror(errno),errno);
    return 0;
}
memset(&servaddr, 0, sizeof(servaddr));
servaddr.sin_family = AF_INET;
servaddr.sin_port = htons(6666);
if( inet_pton(AF_INET, argv[1], &servaddr.sin_addr) <= 0){// 服务器ip+端口
    printf("inet_pton error for %s\n",argv[1]);
    return 0;
}
if( connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0){// 连接服务器
    printf("connect error: %s(errno: %d)\n",strerror(errno),errno);
    return 0;
}
printf("send msg to server: \n");
fgets(sendline, 4096, stdin);
if( send(sockfd, sendline, strlen(sendline), 0) < 0){// 已建立连接，发送信息
    printf("send msg error: %s(errno: %d)\n", strerror(errno), errno);
    return 0;
}
close(sockfd);

/*
 * Server */
int  listenfd, connfd;
struct sockaddr_in  servaddr;
char  buff[4096];
int  n;

if ( (listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ) {// 初始化socket
    printf("create socket error: %s(errno: %d)\n", strerror(errno), errno);
    return 0;
}

memset(&servaddr, 0, sizeof(servaddr));
servaddr.sin_family = AF_INET;
servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
servaddr.sin_port = htons(6666);
if ( bind(listenfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) == -1) {// 端口绑定
    printf("bind socket error: %s(errno: %d)\n", strerror(errno), errno);
    return 0;
}
if ( listen(listenfd, 10) == -1) {// 端口监听
    printf("listen socket error: %s(errno: %d)\n",strerror(errno),errno);
    return 0;
}
printf("======waiting for client's request======\n");
while(1){
    if( (connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1){
        printf("accept socket error: %s(errno: %d)",strerror(errno),errno);
        continue;
    }
    n = recv(connfd, buff, MAXLINE, 0);
    buff[n] = '\0';
    printf("recv msg from client: %s\n", buff);
    close(connfd);
}
close(listenfd);
```



## 四次挥手，为什么客户端最后还要等待2MSL？

解析：MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。

 第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

 第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

 

## 为什么建立连接是三次握手，关闭连接确是四次挥手呢？ 

  解析：建立连接的时候，服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。

  而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。



### 协议常用端口

20  —— (FTP文件传输协议数据连接端口，控制)/TCP 👉表示为TCP端口

21  —— (FTP文件传输协议控制连接端口，数据)/TCP

22  —— (SSH远程登陆)/TCP

23  —— (Telnet远程登陆)/TCP

25  —— (SMTP电子邮件传输协议)/TCP

69  —— (TFTP简单文件传输协议)/UDP 👉表示为UDP端口

80  —— (WWW,(**HTTP**超文本传输协议))/TCP

103 —— (PIM组播路由协议端口号)/UDP

109 —— (POP2邮局协议2)/TCP

110 —— (POP3邮局协议3)/TCP

161/ 162—— (SNMP简单网络管理协议)/UDP

443 —— (HTTPS,基于TLS/SSL的网页浏览端口)

614 —— (SSL(加密套接字协议层)SHELL(壳))

HTTP：80



# 进程、线程的概念

## 进程和线程的区别

一个程序就是一个进程，而一个程序中的多个任务则被称为线程。进程是表示资源（CPU、内存等）分配的基本单位，线程是CPU调度和分派的基本单位。 进程和线程的关系：

```markdown
一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。

资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量，即每个线程都有自己的堆栈和局部变量。

```



## 多进程、多线程的优缺点

1）多进程更健壮，一个进程死了不影响其他进程。多线程比较脆弱，一个线程崩溃肯能会影响所有线程，最终使整个程序崩溃。

2） 进程的系统花销远大于线程。

3）多进程的通讯效率不如多线程因为进程的代码段和数据段独立，而多线程可以共享进程里的内存和变量哦。

4） 多进程逻辑控制比较复杂，需要与主进程做好交互。而多线程需要复杂的线程同步和加锁控制等机制。



## 什么时候用进程，什么时候用线程

安全稳定选进程；快速频繁选线程；

1）创建和销毁较频繁使用线程，因为创建进程花销大嘛。

2）需要大量数据传送使用线程，因为多线程切换速度快，不需要跨越进程边界。

3）并行操作使用线程。线程是为了实现并行操作的一个手段，也就是刚才说的需要多个并行操作“合作完成大事”，当然是使用线程啦



## 多进程、多线程同步（通讯）的方法

进程间通讯：

（1）管道/无名管道（2）信号（3）共享内存（4）消息队列（5）信号量（6）socket

注意：临界区则是一种概念，指的是访问公共资源的程序片段，并不是一种通信方式。

线程通讯：

（1）信号量（2）互斥锁（3）读写锁（4）条件变量
提问：互斥锁与信号量的区别？
答：互斥锁用于线程的互斥，信号量用于线程的同步。这是互斥锁和信号量的根本区别，也就是互斥和同步之间的区别。同时互斥锁的作用域仅仅在于线程，信号量可以作用于线程和进程。  



## 进程的基本状态

创建态，就绪态、运行态和阻塞态，终止态。



## 子进程会从父进程继承了什么

子进程从父进程继承的主要有：用户号和用户组号；堆栈；共享内存；目录（当前目录、根目录）；打开文件的描述符；但父进程和子进程拥有独立的地址空间和PID参数、不同的父进程号、自己的文件描述符。



##  一个进程可以创建多少线程，和什么有关

一个进程创建线程的个数由虚拟内存和分配给线程的调用栈大小决定。

**解析：**

创建一个进程，系统会分配4G的虚拟内存，其中1G是内核空间，只有3G是用户空间，也就是我们可以利用来创建线程的空间大小，一个线程的栈的大小可以通过ulimit -s指令来查看，一般大多是8M-10M。

举个例子，这里不放假设我们创建一个线程的栈需要占用10M内存，因此在3G的空间大概可以创建300个线程。此时如果将线程栈大小增加到20M，那么个数就将减少。



## 并发，并行，同步，异步，互斥，阻塞，非阻塞的概念

**并发和并行：** 

并发：任务间交错执行，让串行发生的任务看起来像并行发生一样，单处理器中线程或进程的行为特点。

并行：多个任务同时执行，没有交错。只能在多任务处理器中存在。

**1）同步、互斥：**

互斥：分布在不同进程之间的若干程序片断，规定当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如有**同一个资源同一时间只有一个访问者可以进行访问，其他访问者需要等前一个访问者访问结束才可以开始访问该资源，但互斥无法限制访问者对资源的访问顺序，即访问是无序的**。

同步：每个线程之间按预定的先后次序进行运行，协同、协助、互相配合。**同步就是在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问**。

总结：同步是一种更为复杂的互斥，而互斥是一种特殊的同步。

**2）同步、异步：** 

同步：同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。

异步：异步和同步是相对的，异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。

注意：

1）线程是实现异步的一个方式。可以在主线程创建一个新线程来做某件事，此时主线程不需等待子线程做完而是可以做其他事情。

2）异步和多线程并不是一个同等关系。异步是最终目的，多线程只是我们实现异步的一种手段。

**3）阻塞，非阻塞：**

  阻塞和非阻塞是当进程在访问数据时，根据IO操作的就绪状态不同而采取的不同处理方式，比如主程序调用一个函数要读取一个文件的内容，阻塞方式下主程序会等到函数读取完再继续往下执行，非阻塞方式下，读取函数会立刻返回一个状态值给主程序，主程序不等待文件读取完就继续往下执行。一般来说可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞。

4**）同步阻塞，同步非阻塞，异步阻塞，异步非阻塞：**

以发送方发出请求要接收方读取某文件内容为例。

同步阻塞：发送方发出请求后一直等待（同步），接收方开始读取文件，如果不能马上得到读取结果就一直等，直到获取读取结果再响应发送发，等待期间不可做其他操作（阻塞）。

同步非阻塞：发送方发出请求后一直等待（同步），接收方开始读取文件，如果不能马上的得到读取结果，就立即返回，接收方继续去做其他事情。此时并未响应发送发，发送方一直在等待。直到IO操作（这里是读取文件）完成后，接收方获得读取结果响应发送方，接收方才可以进入下一次请求过程。（实际不应用）

异步阻塞：发送方发出请求后，不等待响应，继续其他工作（异步），接收方读取文件如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作（阻塞）。（实际不应用）

异步非阻塞：发送方发出请求后，不等待响应，继续其他工作（异步），接收方读取文件如果不能马上得到结果，也不等待，而是马上返回取做其他事情。当IO操作（读取文件）完成以后，将完成状态和结果通知接收方，接收方在响应发送方。（效率最高）

**总结：** 

1）同步与异步是对应的，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的。

2）阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞。

3）阻塞是使用同步机制的结果，非阻塞则是使用异步机制的结果。



## 同步一定阻塞吗？阻塞一定同步吗？

线程同步不一定发生阻塞！线程同步的时候，需要协调推进速度，只有当访问同一资源出现互相等待和互相唤醒会发生阻塞。而阻塞了一定是同步，后访问的等待获取资源，线程进入阻塞状态，借以实现多线程同步的过程。



## 孤儿进程、僵尸进程、守护进程

孤儿进程：当父进程退出后它的子进程还在运行

，那么这些子进程就是孤儿进程。孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作。

僵尸进程：当子进程退出后而父进程并未接收结束子进程（如调用waitpid获取子进程的状态信息），那么子进程仍停留在系统中，这就是僵尸进程。

守护进程：是在后台运行不受终端控制的进程（如输入、输出等）。网络服务大部分就是守护进程。



# # 迭代器和指针的不同

1. 迭代器是类模板，表现的像指针，用于遍历STL容器内全部或部分元素”的对象，本质是封装了原生指针，模拟了指针的一些功能，更容易使用；指针是存放地址的指针变量。
3. 指针能指向函数而迭代器不行，迭代器只能指向容器；
3. 迭代器返回的是对象引用而不是对象的值，所以cout输出迭代器的值时要加*。

# 虚函数与纯虚函数的区别

1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。

2. 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。

3. 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。

4. 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口。

5. 虚函数的定义形式：virtual{};纯虚函数的定义形式：virtual  { } = 0;在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时要求前期绑定,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。

虚函数充分体现了面向对象思想中的继承和多态性这两大特性，在C++语言里应用极广。比如在微软的MFC类库中，你会发现很多函数都有virtual关键字，也就是说，它们都是虚函数。难怪有人甚至称虚函数是C++语言的精髓。

定义纯虚函数就是为了让基类不可实例化，因为实例化这样的抽象数据结构本身并没有意义或者给出实现也没有意义。

纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。

虚函数在子类里面也可以不重载的；但纯虚必须在子类去实现，这就像Java的接口一样。通常我们把很多函数加上virtual，是一个好的习惯，虽然牺牲了一些性能，但是增加了面向对象的多态性，因为你很难预料到父类里面的这个函数不在子类里面不去修改它的实现

定义一个函数为虚函数，不代表函数为不被实现的函数。

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。
虚函数只能借助于指针或者引用来达到多态的效果。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

经检验下面的几个函数都不能定义为虚函数：
1）友元函数，它不是类的成员函数
2）全局函数
3）静态成员函数，它没有this指针
3）构造函数，拷贝构造函数，以及赋值运算符重载（可以但是一般不建议作为虚函数）

# 继承，封装，多态

封装就是将数据和操作数据的函数合在一起，使得数据的访问只能通过已定义的接口。封装可以隐藏实现细节，使得代码模块化。

继承可以使子类使用父类的所有功能，并在无需重新编写父类的情况下对这些功能进行扩展。继承主要实现重用代码，节省开发时间。

多态性可以简单地概括为“一个接口，多种方法”，即接口重用。可通过重载和

## 类的public、protect、private顺序

对于类来讲，其最大的贡献是封装，实现面向对象的思想.所以一般程序员关心的是类的接口，即类该怎么用，所以一般public用于修饰函数成员放在最前面，方便阅读。

其次，protected一般用来继承，所以放在中间可以，这也是用户(client)所关心的。

最后，private是保护数据成员的，一般不用用户来关心，所以一般放在最后。当然这是一般情况，也有的程序员为了强调数据的作用，而把private用来修饰数据放在前面，但我强调的是一般情况。







# 二叉排序树(二叉搜索树)，平衡二叉树，红黑树，，的概念

**完全二叉树：** 

若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数$2^{i-1}$，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

出于简便起见，完全二叉树通常采用数组而不是链表存储,

堆一般都是用完全二叉树来实现的，分为大根堆和小根堆，大根堆为根节点的值大于两个子节点的值；小根堆为根节点的值小于两个子节点的值，同时根节点的两个子树也分别是一个堆。（但堆对于两个子节点的大小却没有要求）

**满二叉树：** 

除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。

满二叉树的深度h和最大层数k相同，即k=h;

　　第k层的结点数是： 2^(k-1)

　　总结点数是：$ 2^k-1$ (2的k次方减一)，总节点数一定是奇数。

满二叉树是完全二叉树的特例。

**二叉排序（搜索）树：** 

首先二叉排序树也是一棵二叉树，

1. 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；

2. 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；

3. 它的左右子树也分别为二叉排序树。
   
   构造与节点顺序有关，单个节点的构造复杂度和查询复杂度相同，为O（logn) ~ O(n)。

**平衡二叉树（AVL树）：** 

它或者是一颗空树，或者具有以下性质的二叉排序树：

1. 条件一：它必须是二叉查找树。

2. 条件二：每个节点的左子树和右子树的高度差至多为1。

   平衡二叉树很好的解决了二叉树退化成链表的问题

**红黑树：** 

红黑树和AVL树都是自平衡二叉树。AVL树是完全平衡二叉树，且左右子树都是AVL二叉树，每个节点高度差不大于1。红黑树不追求完全平衡，从而降低旋转的次数。

















