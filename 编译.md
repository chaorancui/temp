[toc]

# 编译

# 编译器

## LLVM

LLVM 的命名最早源自于**底层虚拟机**（**L**ow **L**evel **V**irtual **M**achine）的[首字母缩写](https://zh.wikipedia.org/wiki/首字母缩写)[[5\]](https://zh.wikipedia.org/wiki/LLVM#cite_note-5)，由于这个项目的范围并不局限于建立一个虚拟机，这个缩写导致了广泛的疑惑。LLVM开始成长之后，成为众多编译工具及低端工具技术的统称，使得这个名字变得更不贴切，开发者因而决定放弃这个缩写的意涵[[6\]](https://zh.wikipedia.org/wiki/LLVM#cite_note-6)，现今LLVM已单纯成为一个系统，适用于LLVM下的所有项目，包含**LLVM中介码**（LLVM IR）、**LLVM 调试工具**、**LLVM C++标准函式库**等。

**LLVM**是一套[编译器](https://zh.wikipedia.org/wiki/编译器)基础设施项目，为[自由软件](https://zh.wikipedia.org/wiki/自由软件)，以[C++](https://zh.wikipedia.org/wiki/C%2B%2B)写成，包含一系列模块化的编译器组件和[工具链](https://zh.wikipedia.org/wiki/工具鏈)，用来开发编译器[前端](https://zh.wikipedia.org/wiki/前端)和[后端](https://zh.wikipedia.org/wiki/後端)。它是为了任意一种[编程语言](https://zh.wikipedia.org/wiki/程式語言)而写成的程序，利用[虚拟技术](https://zh.wikipedia.org/wiki/虛擬技術)创造出[编译时期](https://zh.wikipedia.org/wiki/編譯器)、[链接时期](https://zh.wikipedia.org/wiki/链接器)、[执行时期](https://zh.wikipedia.org/wiki/執行時期)以及“闲置时期”的优化。

LLVM 的主要子项目是：

> 参考：<https://llvm.org/>

1. **LLVM 核心**库提供了现代的源和目标独立[优化器](https://llvm.org/docs/Passes.html)，以及 对许多流行 CPU（以及一些不太常见的 CPU）的[代码生成支持！这些库是围绕一个](https://llvm.org/docs/CodeGenerator.html)[明确指定的](https://llvm.org/docs/LangRef.html)代码表示构建的，称为 LLVM 中间表示（“LLVM IR”）。LLVM 核心库有[详尽的文档](https://llvm.org/docs/)，并且特别容易发明自己的语言（或移植现有的编译器）以使用 [LLVM 作为优化器和代码生成器](https://llvm.org/docs/tutorial/)。
2. **[Clang](https://clang.llvm.org/)**是一个“LLVM 原生” C/C++/Objective-C 编译器，旨在提供惊人的快速编译、极其有用的[错误和警告消息](https://clang.llvm.org/diagnostics.html)，并提供一个用于构建出色源代码级工具的平台。Clang[Static Analyzer](https://clang-analyzer.llvm.org/)和 [clang-tidy](https://clang.llvm.org/extra/clang-tidy/)是可以自动查找代码中错误的工具，也是使用 Clang 前端作为解析 C/C++ 代码的库来构建此类工具的绝佳示例。
3. **[LLDB](https://lldb.llvm.org/)**项目基于 LLVM 和 Clang 提供的库，提供出色的本机调试器。它使用 Clang AST 和表达式解析器、LLVM JIT、LLVM 反汇编器等，从而提供“正常工作”的体验。它在加载符号时也非常快，内存效率比 GDB 高得多。
4. libc **[++](https://libcxx.llvm.org/)**和 **[libc++ ABI](https://libcxxabi.llvm.org/)**项目提供了符合标准的高性能 C++ 标准库实现，包括对 C++11 和 C++14 的全面支持。
5. **[Compiler-rt](https://compiler-rt.llvm.org/)**项目提供了经过高度优化的低级代码生成器支持例程实现，例如“ `__fixunsdfdi` ”以及当目标没有一小段本机指令来实现核心 IR 操作时生成的其他调用。它还提供了动态测试工具的运行时库实现，例如 [AddressSanitizer](https://clang.llvm.org/docs/AddressSanitizer.html)、 [ThreadSanitizer](https://clang.llvm.org/docs/ThreadSanitizer.html)、 [MemorySanitizer](https://clang.llvm.org/docs/MemorySanitizer.html)和 [DataFlowSanitizer](https://clang.llvm.org/docs/DataFlowSanitizer.html)。
6. **[MLIR](https://mlir.llvm.org/)**子项目是一种构建可重复使用和可扩展的编译器基础架构的新方法。MLIR 旨在解决软件碎片化问题、改进异构硬件的编译、大幅降低构建特定领域编译器的成本，并帮助将现有编译器连接在一起。
7. OpenMP 子项目提供了一个[OpenMP 运行时](https://openmp.org/)**[，](https://openmp.llvm.org/)**可与 Clang 中的 OpenMP 实现一起使用。
8. polly 项目使用多面体模型实现了一套缓存局部性**[优化](https://polly.llvm.org/)**以及自动并行和矢量化。
9. **[libclc](https://libclc.llvm.org/)**项目旨在实现 OpenCL 标准库。
10. **[klee](https://klee.llvm.org/)**项目实现了一个“符号虚拟机”，它使用定理证明器尝试评估程序中的所有动态路径，以查找错误并证明函数的属性。klee 的一个主要功能是它可以在检测到错误时生成测试用例。
11. **[LLD](https://lld.llvm.org/)**项目是一个新的链接器。它是系统链接器的直接替代品，运行速度更快。
12. **[BOLT](https://github.com/llvm/llvm-project/tree/main/bolt)**项目 是一个后链接优化器。它通过基于采样分析器收集的执行配置文件优化应用程序的代码布局来实现改进。

除了 LLVM 的官方子项目外，还有各种各样的其他项目[使用 LLVM 的组件执行各种任务](https://llvm.org/ProjectsWithLLVM/)。通过这些外部项目，您可以使用 LLVM 编译 Ruby、Python、Haskell、Rust、D、PHP、Pure、Lua、Julia 和许多其他语言。LLVM 的主要优势在于其多功能性、灵活性和可重用性，这就是它被用于各种不同任务的原因：从对 Lua 等嵌入式语言进行轻量级 JIT 编译到为大型超级计算机编译 Fortran 代码。

## 常用 C++ 编译器

C++ 编译器的主要作用是将 C++ 源代码翻译成可执行程序的工具。此外还有代码优化、错误检查、链接和调试支持等多个功能。

常用的 C++ 编译器包括以下几种：

1. **GCC（GNU Compiler Collection）**：
   - **平台**：跨平台，支持 Linux、Windows（通过 MinGW 和 Cygwin）、macOS 等。
   - **特点**：开源，功能强大，支持多种编程语言（如 C、C++、Fortran 等），是 Linux 和 Unix 系统上的默认编译器之一。
2. **Clang**：
   - **平台**：跨平台，支持 Linux、Windows、macOS。
   - **特点**：基于 LLVM，编译速度快，错误信息清晰，开发工具链完善，具有模块化设计。尤其适合用在 macOS 和 iOS 开发中。
3. **MSVC（Microsoft Visual C++）**：
   - **平台**：Windows。
   - **特点**：微软提供的 C++ 编译器，与 Visual Studio 集成，支持 Windows 上的 C++ 开发。对 Windows 平台和 Windows API 支持非常好。
4. **MinGW（Minimalist GNU for Windows）**：
   - **平台**：Windows。
   - **特点**：开源，在 Windows 平台上移植了 GCC 编译器，使得 Windows 用户可以使用 GCC 编译 C++ 程序。建立在 gcc 和 binutils 项目上，除编译器以外还包含一些其他的 GNU 程序开发工具。
5. **Intel C++ Compiler（icc/icx）**：
   - **平台**：跨平台，支持 Linux、Windows、macOS。
   - **特点**：Intel 提供的 C++ 编译器，专门针对 Intel 的处理器进行优化，能够生成高效的二进制代码，适用于高性能计算和科学计算领域。
6. **Embarcadero C++ Builder**：
   - **平台**：Windows。
   - **特点**：集成开发环境 (IDE) 中包含的编译器，支持快速应用程序开发，专注于 GUI 应用和数据库开发。

# 构建工具

**构建工具** 是开发软件时用于**自动化管理项目编译、链接和生成可执行文件**的工具。在大型项目中，手动编译源代码会非常复杂，因为项目通常包含多个源文件、库文件以及依赖项。构建工具简化了这些繁琐的步骤，使开发者能够专注于编写代码，而无需手动处理编译和构建过程中的细节。

**CMake** 和 **Make** 是两种常用的构建工具，但它们在用途和工作方式上有一定的差异。下面是对它们的作用、工作流程以及如何配合使用的详细解释。

## Make

1. 作用

   `Make` 是一种用于自动化构建过程的工具。它可以通过定义规则和依赖关系，决定哪些文件需要重新编译，从而生成最终的目标文件或可执行文件。

2. 工作原理

   - `Make` 依赖于一个名为 `Makefile` 的文件，该文件定义了构建规则。Makefile 指定了目标文件、依赖关系以及执行这些目标的命令。

   - `Makefile` 中的基本格式：

     ```makefile
     target: dependencies
         command
     ```

     例如，假设你有一个简单的 C++ 项目，包含一个源文件 `main.cpp`，可以使用 `Makefile` 进行编译：

     ```makefile
     main: main.o
         g++ -o main main.o

     main.o: main.cpp
         g++ -c main.cpp
     ```

     在运行 `make` 后，它会根据文件的依赖关系决定是否重新编译某些文件。

3. 特点

   - **简单高效**：适合较小项目，手动编写 Makefile 可以帮助开发者灵活控制构建过程。
   - **依赖手动管理**：Makefile 中的依赖关系需要开发者自行维护，项目复杂时管理起来比较困难。

## CMake

1. 作用

   `CMake` 是一种跨平台的构建工具，它的主要功能是生成项目的构建文件（如 Makefile、Visual Studio 项目文件、Ninja 文件等）。`CMake` 不是直接执行构建过程的工具，而是通过生成适合目标平台的构建配置文件来间接执行编译过程。

2. 工作原理

   - `CMake` 使用一个名为 `CMakeLists.txt` 的配置文件，来定义项目的构建规则。然后，`CMake` 根据这些规则生成具体平台上的构建文件。

   - 例如，一个简单的 `CMakeLists.txt` 可能如下：

     ```cmake
     cmake_minimum_required(VERSION 3.10)
     project(MyProject)

     add_executable(my_executable main.cpp)
     ```

     这个 `CMakeLists.txt` 文件定义了一个名为 `MyProject` 的项目，并指定了可执行文件 `my_executable` 由 `main.cpp` 构建。

   - 运行 CMake 的典型步骤：

     1. 使用 CMake 生成构建文件：

        ```shell
        cmake .
        ```

        这会根据 `CMakeLists.txt` 生成相应的 Makefile（如果在类 Unix 环境下）或其他平台相关的构建文件。

     2. 使用生成的 Makefile 执行编译：

        ```shell
        make
        ```

        这样就会根据生成的 Makefile 进行编译和链接。

3. 特点

   - **跨平台支持**：CMake 能生成适合不同平台的构建文件，方便开发者编写跨平台的代码。
   - **自动化管理依赖**：CMake 可以自动检测项目中的依赖库、头文件路径等，减少了手动管理的复杂度。
   - **模块化**：CMake 提供了模块化的设计，允许开发者在大型项目中轻松管理多个子项目。

## CMake 与 Make 的关系

- `CMake` 本质上是一个 **构建系统生成器**，它负责生成类似 `Makefile` 的构建文件，而 **Make** 是一个 **构建系统执行器**，根据生成的 `Makefile` 执行实际的构建过程。
- 对于一个项目，CMake 负责高层次的构建配置，而 Make 则负责实际的构建任务。在类 Unix 系统上，CMake 通常会生成 Makefile，之后开发者再使用 Make 命令进行编译。

CMake 与 Make 的组合使用，典型的使用流程如下：

1. **编写 CMake 配置文件**：项目中包含一个 `CMakeLists.txt` 文件，定义项目的构建规则。

2. 生成构建文件

   ：运行 CMake，生成 Makefile 或其他构建文件。

   ```shell
   cmake .
   ```

3. 编译项目

   ：使用 Make 编译项目。

   ```shell
   make
   ```

**总结**：

- **Make**：是一个底层的构建工具，依赖于 Makefile 来管理构建流程。适合小项目，但大型项目依赖管理麻烦。
- **CMake**：是一个构建系统生成器，可以自动生成跨平台的构建文件，极大简化了复杂项目的依赖管理。它通常与 Make 配合使用来实现项目的编译。

## 知识

### ext_vector_type

`ext_vector_type` 是一个 C++ 语言扩展，主要用于 OpenCL 和一些特定的 GPU 编程场景。这个扩展并不是标准 C++ 的一部分，而是由一些编译器（如 Clang）提供的特殊功能。让我为您详细介绍一下：

1. 用途：
   `ext_vector_type` 主要用于定义固定长度的向量类型，这在图形编程和并行计算中非常有用。

2. 语法：
   通常的语法形式为：

   ```cpp
   typedef __attribute__((ext_vector_type(N))) T vector_name;
   // 或
   typedef T vector_name __attribute__((ext_vector_type(N)));
   ```

   其中 N 是向量的长度，T 是基本数据类型（如 int, float 等）。

3. 示例：

   ```cpp
   typedef float float4 __attribute__((ext_vector_type(4)));
   float4 v = {1.0f, 2.0f, 3.0f, 4.0f};
   ```

4. 特性：

   - 支持常见的向量操作，如加法、乘法等。
   - 允许使用下标访问单个元素。
   - 支持使用 .xyzw 或 .rgba 等方式访问分量。

5. 优势：

   - 性能：可以利用 SIMD（单指令多数据）指令进行优化。
   - 可读性：使代码更加简洁，特别是在处理 3D 图形时。

6. 使用场景：

   - OpenCL 编程
   - GPU 编程
   - 图形处理
   - 科学计算

7. 注意事项：

   - 这是编译器特定的扩展，不是标准 C++。
   - 可能会影响代码的可移植性。

8. 替代方案：

   - 在标准 C++ 中，可以使用 `std::array` 或自定义类来实现类似功能。
   - 一些图形库（如 GLM）提供了类似的向量类型。

9. 编译器支持：

   - 主要由 Clang 支持。
   - 其他编译器可能有类似的扩展，但语法可能不同。

虽然 `ext_vector_type` 在特定领域非常有用，但在通用 C++ 编程中并不常见。如果您正在进行 OpenCL 或 GPU 编程，了解这个扩展会很有帮助。但如果您主要关注标准 C++ 编程，可能需要考虑更加标准化的替代方案。

# GDB

## GDB 常用命令总结

> :pencil: **参考链接**：
>
> 1. [【Linux】GDB 入门笔记](https://imageslr.com/2023/gdb.html#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8)
> 2. [gdb 常用指令](https://jasonblog.github.io/note/gdb/gdbchang_yong_zhi_ling.html)
> 3. [GDB 官方文档 | 主页](http://sourceware.org/gdb/current/onlinedocs/gdb/index.html)
> 4. [GDB 官方文档 | 命令脚本](https://sourceware.org/gdb/current/onlinedocs/gdb.html/Command-Files.html)
> 5. [GDB 命令基础，让你的程序 bug 无处躲藏](https://deepzz.com/post/gdb-debug.html)
> 6. [GDB 用法详解(5 小时快速教程)](https://www.cnblogs.com/lvdongjie/p/8994092.html)
>
> :bulb: **提示**：
> 进入 GDB 后，可以使用 `help xx` 命令显示帮助信息。如 `help info` 会列出 info 的帮助信息。

GDB（GNU Debugger）是一个非常强大的调试工具，常用于调试 C、C++等程序。下面是一些常用的 GDB 命令：

**基本启动和退出**：

- **gdb my_program**：启动 GDB 并调试指定的程序。

- **set args arg1 arg2**：使用 `gdb my_program` 启动 GDB 调试后，用 `set args` 设置程序运行时的参数。

- **gdb --args my_program arg1 arg2**：启动调试程序并传入参数，可以使用 --args 选项。与上面 2 条等价。

- **gdb my_program core_file**：调试程序的 core 文件。

- **quit** 或 **q**：退出 GDB。

```shell
$ gdb ./my_program
(gdb) set args arg1 arg2
(gdb) break main
(gdb) run

# 或
$ gdb --args ./my_program arg1 arg2
(gdb) run
```

**运行程序与执行**：

- **run** 或 **r**：启动程序。

  - **run arg1 arg2**：带参数启动程序。
  - **run < input_file**：使用输入重定向。

- **start**：运行程序并在 main 函数处暂停。

- **continue** 或 **c**：继续运行程序，直到遇到下一个断点或结束。

- **next** 或 **n**：执行下一行代码（不进入函数）。

- **step** 或 **s**：执行下一行代码（如果是函数调用，则进入函数）。

- **finish**：继续运行直到当前函数执行完毕。

- **until**：继续运行直到当前循环结束或执行到某一行。

**断点**：

- **break main** 或 **b main**：在`main`函数处设置断点。

- **break [file:]line_number**：在指定文件的某一行设置断点。

  - **break file.c:42**：在`file.c`文件的第 42 行设置断点。
  - **break 42**：在当前源文件的第 42 行设置断点。

- **break function_name**：在指定函数处设置断点。

- **break line_number if condition**：某一行设置条件断点。

- **break function_name if condition**：设置有条件的断点，只有条件满足时才会暂停程序。

  - **break main if i == 10**：在`main`函数处设置断点，当`i == 10`时才会触发。

- **commands**断点命令列表：在执行到某个断点后，使用命令列表进行一系列操作，如一次性添加多个断点。

- **info breakpoints** 或 **info b**：列出所有断点。

- **clear**：清除当前位置的断点。

- **delete <断点号>**：删除特定断点，多个断点可用空格分隔。

- **delete**：删除所有断点。

- **disable**：禁用所有断点。

**栈和栈帧**：

- **backtrace** 或 **bt**：显示当前调用栈。

- **backtrace n** 或 **bt n**：显示最顶端的 n 个调用栈。

- **backtrace full**：显示更详细的调用栈信息，包括所有参数和局部变量的值。

- **frame** 或 **f**：显示当前栈帧的详细信息，包括源代码行。

- **frame n** 或 **f n**：切换到第 `n` 个栈帧，使你可以查看该帧的局部变量和参数。

- **info frame**：显示当前栈帧的信息，如返回地址和帧指针。

- **info stack**：查看栈帧信息。跟 **bt** 命令结果一样。

**变量**：

- **print variable_name** 或 **p variable_name**：打印变量的值。

  - **print a[3]**：打印数组`a`的第 3 个元素。
  - **print \*p**：查看指针 `p` 指向的数组/结构体/类的所有成员。
  - **print p->member**：查看指针 `p` 指向的结构体的某个具体成员。

- **info locals**：查看当前函数中的局部变量。

- **info args**：查看当前函数的参数。

- **info registers**：显示寄存器的内容。

- **set variable_name = value**：修改变量的值。

  - **set a[3] = 10**：将数组`a`的第 3 个元素设置为 10。
  - **set $i = 0**：以 `$` 开头的变量是 GDB 会话的临时变量，帮助 GDB 区分调试器的变量和被调试程序的变量。

- **info macro <宏名>**：查看特定宏的定义。

- **display <变量名>**：在每次暂停时显示变量的值（包括所有断点和单步执行），无需绑定到特定断点。

  - `display x`：每次暂停时显示变量 x 的值。

- **undisplay <display 编号>**：停止显示该变量。

  - `undisplay 1`：停止显示第一个 display 的变量。

- **info display <display 编号>**：查看自动显示列表。
  其中，各列的含义为：

  - **Num 列**：为各变量或表达式的编号，GDB 调试器为每个变量或表达式都分配有唯一的编号；
  - **Enb 列**：表示当前各个变量（表达式）是处于激活状态还是禁用状态，如果处于激活状态（用 y 表示），则每次程序停止执行，该变量的值都会被打印出来；反之，如果处于禁用状态（用 n 表示），则该变量（表达式）的值不会被打印。
  - **Expression 列**：表示查看的变量或表达式。

- **enable display <display 编号>**：启用变量的自动显示。
- **disable display <display 编号>**：禁用变量的自动显示。

> 在 GDB 里，`.` 和 `->` 是一样的，所以无论 `ptr` 是否是指针，都可以用 `p.field` 打印字段的值。

**源码**：

- **info line**：显示当前行的详细信息，包括源文件和行号。

- **info source**：显示源代码文件信息。

- **list** 或 **l**：显示当前帧的源代码，通常显示前几行和后几行。
- **list line_number**：显示指定行号的源代码。

**内存检查**：

- **x/nfu address**：显示内存内容，其中

  1. `x` 是 examine （检查）的缩写。
  2. `n` 是要显示的单元数量，
  3. `f` 是格式（如`x` 为十六进制，`d` 为十进制），
  4. `u` 是单元的大小（如`b` 为字节，`h` 为半字，`w` 为字）。

  - **x/4xw 0x601050**：显示从地址`0x601050`开始的 4 个字的内存，以十六进制格式显示。

**分析**：

- **disassemble**：反汇编当前函数的代码。
- **info line**：显示当前行的内存地址。

**调试共享库**：

- **info sharedlibrary**：显示加载的共享库信息。
- **sharedlibrary**：加载共享库的符号表。

这些是 GDB 最常用的一些命令，灵活使用这些命令可以帮助你更高效地调试程序。

## GDB 中 print

在 GDB（GNU Debugger）中，`print` 命令是用来查看变量的值或者计算表达式的结果。它不仅可以查看普通的变量，还能对复杂的表达式进行求值，比如函数调用、结构体成员、数组元素等。

**print variable_name** 或 **p variable_name**：打印变量的值。

- **print a[3]**：打印数组`a`的第 3 个元素。
- **print \*p**：查看指针 `p` 指向的数组/结构体/类的所有成员。
- **print p->member**：查看指针 `p` 指向的结构体的某个具体成员。
- **print 格式化打印**：`p/x foo` 或 `print/x foo`
  - `p/a`：将变量解释为指针 address，使用十六进制打印
  - `p/c`：将变量解释为字符 char，打印为字符
  - `p/o`：使用八进制打印变量
  - `p/x`：使用十六进制打印变量
  - `p/u`：将变量解释为无符号整数 unsigned，使用十进制打印
  - `p/s`：将变量解释为字符串，打印输出
  - `help x` 可以查看全部 Format letters。

> 未找到 print 一行打印多个参数的方法

## GDB 中 printf

Formatted printing, like the C "printf" function.
Usage: printf "format string", ARG1, ARG2, ARG3, ..., ARGN
This supports most C printf format specifications, like %s, %d, etc.

## GDB 中 dprintf

待补充

## GDB 中变量

在 GDB 中，`$`符号用于表示用户定义的变量或者是 GDB 的内部变量。这种语法有特定的用途和意义：

1. 区分变量：
   `$`符号帮助 GDB 区分调试器的变量和被调试程序的变量。这样可以避免命名冲突。
2. 临时变量：
   以`$`开头的变量是 GDB 会话的临时变量，可以在 GDB 命令中使用它们进行计算或存储中间结果。
3. 内部寄存器：
   GDB 使用`$`符号来引用 CPU 寄存器。例如，`$eax`表示 x86 架构中的 EAX 寄存器。
4. 特殊变量：
   GDB 有一些预定义的特殊变量，如`$_`（上一个表达式的值）和`$$`（倒数第二个表达式的值）。
5. 命令参数：
   在自定义命令中，`$argN`用于引用第 N 个参数。例如，`$arg0`是第一个参数。

使用示例：

```gdb
(gdb) set $i = 0               # 设置一个名为i的GDB变量
(gdb) print $i                 # 打印i的值
$1 = 0
(gdb) set $result = $i + 5     # 使用i进行计算并存储结果
(gdb) print $result
$2 = 5
(gdb) print $eax               # 打印EAX寄存器的值（在x86系统上）
```

在自定义命令中：

```gdb
define my_command
    set $local_var = $arg0 + $arg1   # 使用命令参数
    print $local_var
end
```

使用`$`的好处是可以清晰地区分 GDB 的变量和程序的变量，避免混淆。例如，如果你的 C 程序中有一个名为`i`的全局变量，你可以使用`i`来引用程序的变量，使用`$i`来引用 GDB 的变量。

这种区分对于调试复杂程序特别有用，因为它允许你在不影响程序状态的情况下操作和存储临时数据。

需要注意的是，这些以`$`开头的变量只在当前 GDB 会话中有效，退出 GDB 后就会消失。如果需要在多个 GDB 会话之间保持变量，你可能需要考虑使用 GDB 的保存命令或脚本。

## GDB 自定义命令脚本

GDB 自定义命令通常定义在文件中，这样可以更方便地管理和重用这些命令。以下是如何定义和让 GDB 感知自定义命令的步骤：

1. **在 `.gdbinit` 文件中定义命令**

   通常，GDB 自定义命令定义在一个名为`.gdbinit`的初始化文件中。这个文件可以放在以下位置：

   - 用户主目录（`~/.gdbinit`）：对当前用户的所有 GDB 会话生效
   - 当前工作目录（`./.gdbinit`）：只对当前目录下的 GDB 会话生效
   - 自定义路径的文件：可以在启动 GDB 时指定

   可以打开`.gdbinit`文件，直接添加你的自定义命令。例如下面打印全局数组 array 的前 5 个元素的命令：

   ```gdb
   define print_array
       set $i = 0
       while $i < $arg0
           print array[$i]
           set $i = $i + 1
       end
   end

   document print_array
   Prints the first n elements of the global array 'array'.
   Usage: print_array n
   end
   ```

2. **加载 `.gdbinit` 文件**

   1. 自动加载：

      如果 `.gdbinit` 文件在用户主目录或当前工作目录，GDB 会自动加载它。

   2. 启动时用 `-x` 指定文件：

      ```shell
      gdb -x /path/to/your/gdbinit program
      ```

   3. 在 GDB 会话中用 `source` 手动加载：

      在 GDB 提示符下使用

      ```gdb
      (gdb) source /path/to/your/gdbinit
      ```

3. **验证命令已加载**：
   在 GDB 中，你可以使用 `help user-defined` 命令来查看所有已定义的自定义命令。
   一旦命令被加载，你就可以在 GDB 中直接使用它们，就像内置命令一样。

4. **安全考虑**：
   默认情况下，GDB 可能会**禁用自动加载**本地 `.gdbinit` 文件（当前目录下的）以防安全风险。如果遇到这种情况，你可以在用户主目录的 `.gdbinit` 中添加以下行来启用它：

   ```gdb
   (gdb) set auto-load safe-path /
   ```

   或者在启动 GDB 时使用 `-nx` 选项忽略所有自动加载的初始化文件，然后手动加载你信任的文件。

5. **删除自定义命令**

   1. **删除单个自定义命令**

      如果你知道自定义命令的名称，可以使用以下命令删除某个特定的自定义命令：

      ```gdb
      undefine <command_name>
      ```

   2. **删除所有自定义命令**

      GDB 并没有提供一个直接的命令来删除所有自定义命令，因此，你需要手动删除每个已定义的自定义命令。如果你不确定有哪些自定义命令，可以使用 `show user` 列出当前所有自定义的命令：

      ```gdb
      show user
      ```

      这将列出所有用户定义的命令和别名。然后，你可以逐个使用 `undefine` 来删除这些命令。

   3. **通过重新启动 GDB**

      如果你想立即清除所有自定义命令，最简单的方式就是重新启动 GDB。由于自定义命令只在当前 GDB 会话中有效，重启 GDB 将清除所有这些命令。

      ```bash
      quit  # 退出 GDB
      gdb <your_program>  # 重新启动 GDB
      ```

   4. **修改 GDB 初始化文件**

      如果你在 `.gdbinit` 文件中定义了自定义命令，确保从 `.gdbinit` 中移除这些命令，以防它们在下次启动 GDB 时重新加载。

      你可以通过编辑 `~/.gdbinit` 文件并删除相应的命令定义来清除所有自定义命令。

      ```bash
      nano ~/.gdbinit  # 使用你喜欢的编辑器打开 .gdbinit 文件
      ```

      然后删除或注释掉相关的命令定义部分。

   5. **总结**

   - 使用 `undefine <command_name>` 来删除特定的自定义命令。
   - 使用 `show user` 查看已定义的自定义命令。
   - 重新启动 GDB 来清除所有命令。
   - 编辑 `.gdbinit` 文件来防止命令重新加载。

通过这种方式，你可以创建和管理复杂的 GDB 命令集，大大提高调试效率。

## GDB 自定义命令语法

> 1. [GDB 官方文档 | 主页](http://sourceware.org/gdb/current/onlinedocs/gdb/index.html)
> 2. [GDB 官方文档 | 命令脚本](https://sourceware.org/gdb/current/onlinedocs/gdb.html/Command-Files.html)

1. **自定义命令格式**

   ```gdb
   define <command>
      <code>
   end

   document <command>
      <help text>
   end
   ```

   其中 `<code>` 可以是任意 gdb 命令。`<help text>` 是此命令的帮助信息。不知道为什么，只显示一行。

   - 此外自定义命令支持传入参数。**GDB 7.0 及后续版本中支持的参数个数是不受限，GDB 7.0 以前版本支持最多 10 个输入参数**。用 `$arg0，$arg1 …… $arg9` 的语法使用参数，还可用 `$argc` 来标明一共传入了多少参数。
   - gdb 命令本身是没有缩进要求的。但是应该不可以使用 tab 缩进的， 因为 tab 在 gdb 交互界面中是一个用于输出提示命令作用的。
   - 脚本文件的注释也是以 `#` 开头的，这个同很多其它脚本语言都一样。
   - 脚本中一行命令太长时，可以在末尾使用反斜杠 `\` 来表示命令还没有结束，继续输入到下一行。

2. **流控制命令**

   GDB 提供了一组流控制命令来处理这些复杂性。使用这些命令，您可以编写复杂的脚本，循环遍历数据结构、有条件地执行命令等。

   `if`, `else`
   此命令允许在脚本中包含有条件执行的命令。该 if 命令采用单个参数，即要评估的表达式。它后面跟着一系列命令，这些命令只有在表达式为真（其值非零）时才执行。然后可以有一行可选 else，后面跟着一系列命令，这些命令只有在表达式为假时才执行。列表的末尾以包含 end 的行标记。

   `while`
   此命令允许编写循环。其语法类似于 if：该命令采用单个参数，即要计算的表达式，后面必须跟要执行的命令，每行一个命令，以 end 结尾。这些命令称为 while 循环体。只要表达式计算结果为真，就会重复执行循环体中的命令。

   `loop_break`
   此命令退出包含它的 while 循环。脚本在该行之后继续 while 执行 end 。

   `loop_continue`
   此命令跳过包含它的 while 循环中其余命令体。执行分支到 while 循环的开头，并在此计算控制表达式。

   `end`
   终止 if、else 或 while 流控制命令。

> break/continue 已经被使用于 gdb 中的打断点和继续调试的命令，所以 gdb 中的 while 控制结构中不能够再使用这两个来进行结构控制，对应使用的就是 loop_break，loop_continue 这两个。

另外 gdb 还提供了很多输出命令。比方说 echo 命令，如果仅仅是输出一段文本，echo 命令特别方便。此外还有和 C 语言很相似的支持格式化输出的 printf 命令，等等。

## GDB 支持 Python 脚本

GDB 支持 Python 脚本，可以用来批量打印变量：

1. 在 GDB 中输入 Python 交互模式：

   ```gdb
   (gdb) python
   ```

2. 编写 Python 代码打印变量：

   ```python
   for var in ['var1', 'var2', 'var3']:
       print(gdb.parse_and_eval(var))
   ```

3. 输入完后，退出 Python 模式：

   ```python
   end
   ```

## 条件断点

**break … if cond**：设置有条件的断点，只有条件满足时才会暂停程序。

1. std::string
   有些 GDB 版本无法直接使用 `==` 操作符是因为 GDB 不能直接解析 C++ 的运算符重载。这时候可以使用下面的前 2 种方式：

   ```cpp
   // 1. 使用 std::string 的 compare
   b ... if (opType.compare("HELLO") == 0)

   // 2. 使用 strcmp
   b ... if (strcmp(opType.c_str(), "HELLO") == 0)

   // 3. 使用 std::string 的 == 运算符，可能 GDB 不支持
   b ... if (opType == "HELLO")
   ```

## 保存和读取断点

在 GDB（GNU Debugger）中，你可以通过以下命令来保存和读取断点：

1. **保存断点到文件**

   你可以使用 `save breakpoints` 命令将当前会话中的断点保存到一个文件中。命令格式如下：

   ```gdb
   (gdb) save breakpoints <filename>

   # 例：将当前所有断点保存到 `breakpoints.txt` 文件中。
   (gdb) save breakpoints breakpoints.txt
   ```

   其中 `<filename>` 是你想要保存断点的文件名。例如：

2. **从文件中读取断点**

   要从文件中加载之前保存的断点，你可以使用 `source` 命令。命令格式如下：

   ```gdb
   (gdb) source <filename>

   # 例如：
   (gdb) source breakpoints.txt
   ```

   这会从 `breakpoints.txt` 中读取并恢复之前保存的所有断点。

3. **总结**

   - 使用 `save breakpoints <filename>` 将断点保存到文件。
   - 使用 `source <filename>` 从文件中读取断点。

   这样可以在不同的调试会话之间保留断点设定，非常方便调试复杂程序。

## 断点命令列表 commands

> [【转载】GDB 高级技巧：边 Debug 边修复 BUG，无需修改代码，无需重新编译](https://www.cnblogs.com/dongxb/p/18240597)

GDB 支持在断点触发后，自动执行用户使用 `commands` 预设的一组调试命令，而无需手动输入。

**使用 `commands` 的步骤**：

1. **设置断点** 首先，你需要在程序中设置一个断点。在你的代码中，可以在某个函数或行号上设置断点，例如：

   ```gdb
   (gdb) break main
   ```

2. **定义 `commands`** 一旦设置了断点，使用 `commands` 命令来定义你希望在该断点被触发时自动执行的命令。使用 `end` 命令结束命令列表。例如：

   ```gdb
   (gdb) commands
   > print targetData
   > print targetData.get()
   > x/10bx targetData.get()
   > continue
   > end
   ```

   - `>` 后面的每一行都是你希望在断点处执行的命令。
   - `continue` 可以让程序在执行完这些命令后继续运行。

3. **运行程序** 运行程序后，当程序执行到你设置的断点时，`gdb` 将自动执行你定义的所有命令：

   ```gdb
   (gdb) run
   ```

4. **查看结果** 当程序在断点处停止时，所有定义的命令将自动执行，输出将显示在 `gdb` 的控制台上。

5. **取消 commands：**

   方法 1：使用 `commands` 清空命令

   ```shell
   (gdb) commands <breakpoint-number>
   > end
   ```

   这会把断点 <breakpoint-number> 的自动命令列表清空，相当于**取消自动执行命令**。不带 <breakpoint-number> 则表示当前断点。

   方法 2：删除断点再重新设置

   ```shell
   (gdb) delete <breakpoint-number>
   (gdb) break <location>
   ```

**示例**：

假设你有一个简单的 C++ 程序，如下：

```cpp
#include <iostream>
#include <memory>

int main() {
    size_t targetSize = 10;
    std::shared_ptr<uint8_t> targetData(new (std::nothrow) uint8_t[targetSize], std::default_delete<uint8_t[]>());
    for (size_t i = 0; i < targetSize; ++i) {
        targetData.get()[i] = static_cast<uint8_t>(i + 1);
    }
    return 0;
}
```

在 `gdb` 中，你可以如下操作：

```gdb
(gdb) break main
(gdb) commands
> print targetData
> print targetData.get()
> x/10bx targetData.get()
> continue
> end
(gdb) run
```

**额外提示**：

- 如果你希望在断点触发后不继续执行程序，可以省略 `continue` 命令。
- 如果你想在不同的断点上使用不同的命令，可以在每个断点处单独定义命令。
- 你可以在命令列表中包含任何 `gdb` 支持的命令，如 `info`, `set`, `backtrace` 等。

这样使用 `commands` 可以让你的调试过程更高效，减少重复输入命令的麻烦。

## backtrace 调用栈分析

在使用 `bt`（backtrace）查看调用栈之后，你可以进行以下几种操作：

1. 查看特定帧的变量

   - **frame** 或 **f**：显示当前栈帧的详细信息，包括源代码行。
   - **frame n** 或 **f n**：切换到第 `n` 个栈帧，使你可以查看该帧的局部变量和参数。
   - **info locals**：查看当前帧的局部变量。
   - **info args**：查看当前帧的参数。

2. 检查源代码

   - **list** 或 **l**：显示当前帧的源代码，通常显示前几行和后几行。
   - **list line_number**：显示指定行号的源代码。

3. 查看和修改变量

   - **print variable_name** 或 **p variable_name**：查看当前帧中变量的值。
   - **set variable_name = value**：修改当前帧中变量的值。

4. 继续调试

   - **continue** 或 **c**：继续执行程序，直到下一个断点或程序结束。
   - **step** 或 **s**：进入当前帧的函数调用。
   - **next** 或 **n**：执行当前帧的下一行，不进入函数。

5. 调用栈的其他信息

   - **backtrace full**：显示更详细的调用栈信息，包括所有参数和局部变量的值。
   - **info frame**：显示当前栈帧的信息，如返回地址和帧指针。

6. 其他分析

   - **disassemble**：反汇编当前栈帧的代码。
   - **info register**：查看寄存器的状态，了解程序执行的上下文。

通过这些操作，你可以深入分析程序的执行状态，定位问题并进行调试。

## ptype 用法

在 GDB 中，`ptype` 命令用于显示**变量、表达式或类型的声明和定义**信息，尤其适用于查看类、结构体、指针、函数等的类型信息。`ptype` 命令会显示变量的**静态类型**，也就是编译时确定的类型。

1. 查看普通变量/表达式类型：
   `ptype` 会显示该变量的类型定义，包括其数据类型、指针类型或引用类型等。

   ```bash
   (gdb) ptype myInt
   type = int
   ```

2. 查看指针类型：

   ```bash
   (gdb) ptype myPointer
   type = MyClass *
   ```

3. 查看类的完整定义：
   GDB 会显示该类或结构体的完整定义，包括成员变量和成员函数。

   ```bash
   (gdb) ptype myObject
   type = class MyClass {
       public:
         int x;
         void myFunction();
   }
   ```

4. 查看函数类型：

   ```bash
   (gdb) ptype myFunction
   type = int (int, float)
   ```

5. 查看模板类型
   对于 C++ 中的模板类或模板函数，`ptype` 也可以显示模板参数的实例化情况：

   ```bash
   (gdb) ptype templateObject
   ```

- `ptype` 是一个非常有用的工具，可以帮助你在调试过程中了解变量、指针、结构体、类、函数的类型。
- 它可以揭示 C++ 中复杂的类型关系，尤其是在处理类继承、多态、模板和指针时非常有用。

## 继承、多态的调试

在 GDB 中，使用 `ptype` 命令可以查看变量的静态类型（编译时类型），但是在处理类的继承和多态时，指针或引用可能指向的是父类类型，而实际对象是子类对象。为了区分指针或引用实际指向的是父类对象还是子类对象，你需要结合运行时类型信息（RTTI）来判断。

以下是具体的方法和步骤：

### 查看静态类型

`ptype` 显示的是静态类型，即在编译时编译器看到的类型。例如，如果你有一个**指向基类对象的指针或引用**，即使它指向的是派生类对象，`ptype` 只能显示它的基类类型。

假设有以下类定义：

```cpp
class Base {
public:
    virtual void foo() {}
};

class Derived : public Base {
public:
    void foo() override {}
};
```

并且在程序中有如下代码：

```cpp
Base *ptr = new Derived();
```

如果你在 GDB 中使用 `ptype` 查看 `ptr` 的类型：

```bash
(gdb) ptype ptr
type = class Base *
```

输出显示 `ptr` 是指向 `Base` 类型的指针，这仅是编译时的信息，并不能确认它是否指向 `Derived` 对象。

有时会遇到 GDB 无法解析类的完整定义，显示 `<incomplete type>`。通常有以下几种可能原因：

- GDB 找不到类的完整定义。可能是因为调试信息不完整，源代码没有完全编译为带有调试符号的版本（例如未使用 -g 选项编译）。
  解决：确保使用了 -g 编译选项来生成调试信息。如果没有，可以重新编译代码，确保所有相关文件都包含调试信息。
- 该类可能被前向声明（forward declaration）了，但在当前作用域中没有定义。
  解决：检查源代码和库的可见性：确保 GDB 能够访问到定义类的完整头文件或库的符号。
- 如果该类是通过动态库或外部库定义的，而调试器无法访问这些库的调试符号文件，也会导致显示不完整。
  解决：如果该类在外部库中定义，确认是否加载了该库的调试符号。

  **经验**：如果类是纯虚类，自己尝试无法获取类的具体类型。放弃 -\_-!!

### 查看动态类型

借助 C++ 的 RTTI 机制来查看运行时类型。RTTI（Runtime Type Identification）是“运行时类型识别”的意思。 C++ 引入这个机制是为了让程序在运行时能根据基类的指针或引用来获得该指针或引用所指的对象的实际类型。

由于多态行为，`ptr` 可能指向派生类的对象。为了确认指针实际指向的是哪个类型的对象，你可以使用 GDB 的 `print` 命令结合 C++ 的 `typeid` 或 `dynamic_cast` 来检查运行时的动态类型。

1. 使用 `typeid`

   `typeid` 结合 GDB 可以用来获取指针指向对象的实际类型。
   如果 `ptr` 实际指向的是 `Derived` 类的对象，那么输出会是派生类 `Derived` 的类型名。例如：

   ```bash
   (gdb) print typeid(*ptr).name()
   $1 = "Derived"

   # 也可以尝试
   (gdb) print typeid(*ptr)
   ```

   这说明 `ptr` 实际上指向 `Derived` 类型的对象。
   &nbsp;
   :book: **补充**：
   1> **`typeid(*ptr)` 介绍**：
   `typeid(*ptr)` 返回的是一个 `__cxxabiv1::__si_class_type_info` 对象。`__cxxabiv1::__si_class_type_info` 是标准 C++ ABI（应用二进制接口）中的类型信息类，通常用于表示单继承的类型结构。

   - **`__name` 字段**：指向 `typeinfo name for Derived`，表示 `ptr` 实际指向的对象是 `Derived` 类型。这个名字用 C++ 的修饰名（mangled name）表示，`7Derived` 是修饰名，解码后为 `Derived`。
   - **`__base_type` 字段**：指向 `typeinfo for Base`，表示 `Derived` 继承自 `Base`。
   - **`_vptr.type_info` 字段**：指向虚表（vtable）条目，说明对象的虚函数表位置。虚表用于支持 C++ 的运行时多态性。

   &nbsp;
   2> **`typeid()` 无效**：

   - 可能的原因：当 Base 类没有虚函数时，C++ 编译器不会启用运行时类型识别（RTTI）。在这种情况下，typeid 会根据 静态类型（即编译时确定的类型）来判断对象的类型，而不是动态类型。因此要正确使用 typeid 进行多态类型识别（RTTI），**必须确保基类中至少有一个虚函数**。
   - 解决方法：为了让 typeid 正确识别动态类型，必须确保 Base 类至少有一个虚函数，通常是虚析构函数。这样，C++ 编译器才能在运行时获取对象的实际类型（多态性）。
   - 总结：**虚函数**（虚析构函数或其他虚函数）是启用 **RTTI** 和 **多态类型识别** 的关键。没有虚函数时，`typeid` 无法识别多态类型，它只能依据静态类型来判断。使用虚析构函数或其他虚函数后，`typeid` 会返回对象的 **动态类型**，即它在运行时实际所指向的类型。

2. 使用 `dynamic_cast`

   你还可以使用 `dynamic_cast` 来判断指针是否能被安全地转换为派生类指针。如果 `ptr` 实际上指向派生类的对象，`dynamic_cast` 会返回一个有效的指针；否则，它会返回 `nullptr`。

   ```bash
   (gdb) print dynamic_cast<Derived*>(ptr)
   ```

   如果返回非空指针，说明 `ptr` 实际上指向 `Derived` 类型的对象。

### 查看实际指向的对象

你可以使用 `print` 或 `info` 命令查看指针实际指向的对象。如果你想知道指针实际指向的内存块是什么类型，你可以强制类型转换：

```bash
(gdb) print *ptr
```

这会显示 `ptr` 指向的对象的内容。如果指针类型是父类，但实际对象是子类，输出可能会显示基类的成员信息而非子类的。

### 使用 `info vtbl` 命令

GDB 的 `info vtbl` 命令可以用来查看虚表（vtable）信息，这也是判断一个对象实际类型的方式之一。通过检查虚表，你可以看到对象的虚函数表指向的是基类还是派生类。

首先确保启用了虚表显示：

```bash
(gdb) set print vtbl on
```

然后直接查看指针 `ptr` 的虚表信息：

```bash
(gdb) info vtbl *ptr
```

这会显示 `ptr` 实际的虚表指针和它指向的对象类型。如果 `ptr` 实际指向 `Derived` 类型的对象，你会看到 `Derived` 类的虚表信息。

```cpp
class Base {
public:
    virtual ~Base() {}
    virtual void foo() {}
};

class Derived : public Base {
public:
    void foo() override {}
};

Base *ptr = new Derived();
```

**总结**：

- `ptype` 只能显示变量的**静态类型**，也就是在编译时确定的类型。
- 如果你想知道指针或引用实际指向的对象类型（运行时类型），需要结合 C++ 的 RTTI，使用 `typeid` 和 `dynamic_cast` 来确认指向的实际是父类对象还是子类对象。
- `info vtbl` 可以帮助你查看对象的虚表，从而确定多态对象的实际类型。

在 GDB 中，你可以通过以下步骤确认指针实际指向的对象类型：

1. 使用 `ptype` 查看静态类型

   ```bash
   (gdb) ptype ptr
   type = class Base *
   ```

2. 使用 `typeid` 查看动态类型

   ```bash
   (gdb) print typeid(*ptr).name()
   $1 = "Derived"
   ```

3. 使用 `dynamic_cast` 确认类型转换

   ```bash
   (gdb) print dynamic_cast<Derived*>(ptr)
   $2 = (Derived *) 0x5555557582b0
   ```

   这返回了非空指针，说明 `ptr` 实际上指向一个 `Derived` 对象。

4. 使用 `info vtbl` 查看虚表

   ```bash
   (gdb) info vtbl *ptr
   vtable for 'Derived' @ 0x555555758020 (subobject @ 0x5555557582b0)
   [0]: 0x55555555599e <Derived::foo()>
   ```

   可以看到，虚表中显示的是 `Derived` 的虚函数，说明 `ptr` 实际指向的是 `Derived` 类的对象。

## 加载的共享库

`info sharedlibrary` 是 GDB 中用于**显示当前调试程序所加载的共享库**（`.so` 文件）的命令。该命令提供了共享库的加载地址、符号加载状态（是否加载了调试信息），以及共享库的路径等信息。它对于调试涉及多个共享库的程序尤其有用，帮助你确认程序是否正确加载了需要的库，以及是否加载了库的调试符号。

### 基本用法

```bash
(gdb) info sharedlibrary
```

这个命令会输出程序运行时已经加载的共享库的列表，通常会包括共享库的内存地址范围、符号读取状态，以及共享库的文件路径。输出信息通常如下：

```shell
From                To                  Syms Read   Shared Object Library
0x00007ffff7fc5090  0x00007ffff7fee335  Yes         /tmp/ld-linux-x86-64-2.35.so.2
0x00007ffff6bf6440  0x00007ffff6cfdb02  Yes (*)     /lib/x86_64-linux-gnu/libstdc++.so.6
0x00007ffff6a793a0  0x00007ffff6af48e8  Yes         /lib/x86_64-linux-gnu/libm.so.6
0x00007ffff6600700  0x00007ffff6792abd  Yes         /lib/x86_64-linux-gnu/libc.so.6
(*): Shared library is missing debugging information.
```

**输出字段解释**:

1. **From / To**：这些是共享库在程序内存中的加载地址范围。每个共享库会占用一定的内存地址范围，GDB 使用这些地址来管理符号。
2. **Syms Read**：这个字段表示 GDB 是否成功读取了共享库的符号表。通常有两个值：
   - `Yes`：GDB 成功读取了该共享库的符号表，意味着你可以在调试时使用该库中的符号（如函数、类等）。**后面有 `(*)` 表示缺少 debug 信息**。
   - `No`：GDB 没有加载该共享库的符号表，这可能是因为该共享库没有编译时带上调试符号信息（`debug symbols`），或者没有找到该库的调试符号。
3. **Shared Object Library**：这是共享库的实际文件路径。这个字段告诉你共享库是从哪个文件加载的。

**重要提示**：

- 如果某个库的 `Syms Read` 显示为 `No`，并且你希望调试该库的符号，则需要确保该库在编译时包含了调试符号（使用 `-g` 选项）。如果库的调试符号是分离的（通常在 `/usr/lib/debug` 目录下），你可能需要使用 `set debug-file-directory` 命令来指定调试符号文件所在的目录。
- &nbsp;
- `/lib/x86_64-linux-gnu/libc.so.6`：这个库是 C 标准库。
- `/lib/x86_64-linux-gnu/libm.so.6`：这个是数学库。
- `/lib/x86_64-linux-gnu/libpthread.so.0`：这个是线程库。

### 进阶用法

1. 自动加载共享库符号

   有时共享库符号不会自动加载，特别是分离调试符号的情况下。如果你发现某个库的符号没有加载，可以使用 GDB 提供的以下命令手动加载符号：

   ```bash
   (gdb) sharedlibrary libm
   ```

   这将尝试加载库 `libm.so` 的符号表，前提是符号存在或调试符号文件已正确安装。经尝试，若已经加载，此命令不会重新加载。

2. 手动加载调试符号

   如果你有共享库的调试符号文件，但 GDB 没有自动加载它们，你可以使用 `symbol-file` 命令手动加载：

   ```bash
   (gdb) symbol-file /usr/lib/debug/usr/lib/x86_64-linux-gnu/libm.so.debug
   ```

   这会加载 `libm.so` 的调试符号，使 GDB 可以正确解析符号并支持调试。

3. 设置共享库的搜索路径

   如果共享库或其调试符号位于非标准位置，GDB 可能无法自动加载它们。你可以使用以下命令为共享库或调试符号指定搜索路径：

   ```bash
   (gdb) set solib-search-path /path/to/shared/libs
   (gdb) set debug-file-directory /path/to/debug/files
   ```

   `set solib-search-path` 用于指定共享库的搜索路径，而 `set debug-file-directory` 用于指定调试符号文件的搜索路径。

### 重新加载共享库

如果你希望重新运行程序并强制 GDB 重新加载所有共享库，可以使用 `start` 或 `run` 命令重新启动进程。GDB 将**重新加载所有的 `.so` 文件**。

```bash
(gdb) run
# 或者
(gdb) start
```

`start` 会从头开始运行程序并暂停在 `main` 函数之前，允许你在调试时重新加载所有共享库。

**总结**：

`info sharedlibrary` 命令为你提供了查看程序加载的所有共享库及其符号状态的简单方法。通过这个命令，你可以确认共享库是否正确加载，是否包含调试符号，并为进一步的调试提供支持。如果某些库的符号没有被加载，可以通过手动加载符号文件或设置调试符号目录解决问题。

## gdb 加载 so 库符号失败

:x:报错：`error while loading shared libraries:libxxx`

**分析：**

- 如果不存在该共享库，需要先下载或者编译该共享库。

- 如果存在该共享库，但是找不到或者共享库的不对，参考如下：

  系统查看共享库的过程：

  - 首先查找 /etc/ld.so.cache 文件，

    > 而/etc/ld.so.cache 文件的内容是根据 `/lib`、`/usr/lib`、 `/etc/ld.so.conf文件` 这三个内容生成的。注：`/etc/ld.so.conf` 文件包含 `/etc/ld.so.conf.d` 下所有 conf 文件。

  - 如果找不到就查找环境变量里的 LD_LIBRARY_PATH 的值，如果找到了就到对应的目录加载该共享库，

  - 如果都找不到就报 error while loading shared libraries 错误了。

**解决方案：**

对于上述情况 2，可参考如下方法：

- 方法 1：将你的共享库 copy 到 `/lib` 目录或者 `/usr/lib` 目录下（创建符号连接到这 2 个目录下也可），然后执行 `sudo ldconfig` 来重新装载 `/etc/ld.so.cache` 文件。

  ```shell
  # 创建符号链接：如果是因为版本号不对，可以符号连接改为需要的版本号。
  ln -s /home/test/xx.so /usr/lib/xx.so
  ```

- 方法 2：在 `ld.so.conf.d` 目录下创建一个 conf 文件，内容就是你共享库的路径，然后执行 `sudo ldconfig` 来重新装载 `/etc/ld.so.cache` 文件。

  ```shell
  # 仿照已有的 libc.conf，其内容如下

  # libc default configuration
  /usr/local/lib
  ```

- 方法 3：将共享库的路径添加到环境变量 `LD_LIBRARY_PATH` 里，如：

  ```shell
  export LD_LIBRARY_PATH=/home/test:$LD_LIBRARY_PATH
  ```

- 方法 4：使用 GDB 加载库

  进入 GDB 后，使用如下命令查看加载的动态库

  ```shell
  info sharedlibrary
  # 查看 Syms Read 字段为 No, 表示对应 so 库符号加载失败。
  ```

  设置 gdb 的 `solib-search-path` 选项， 指定加载失败的 so 的搜索路径即可，若指定多个路径需要用冒号分隔

  ```shell
  set solib-search-path /usr/local/xxx
  ```

## 延迟断点

> 参考链接：
> [动态库延迟断点实现机制](https://blog.csdn.net/Dong_HFUT/article/details/126069052?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-126069052-blog-105067983.235^v43^pc_blog_bottom_relevance_base3&spm=1001.2101.3001.4242.3&utm_relevant_index=5)

如果可执行程序使用动态链接生成，gdb 刚启动时，若断点打在动态库的符号上，因为动态库还未加载，gdb 会提示该符号找不到，并请求是否设置 pending 断点，这种断点即为延迟断点。若该符号在动态库中存在，在接下来的调试过程中就会命中该断点。例如：

```shell
(gdb) b foo
Function "foo" not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 1 (foo) pending.
```

GDB 会询问是否要在将来加载动态库的时候设置断点，选择 y 即可。

# 库/可执行文件分析

## readelf

`readelf` 是一个非常有用的命令行工具，用于分析 ELF（Executable and Linkable Format）格式的文件。ELF 是在 Unix 和类 Unix 系统（如 Linux）上使用的标准二进制文件格式，用于可执行文件、目标代码、共享库和核心转储。

readelf 命令的常用选项包括：

-h：显示 ELF 文件头信息。
-l：显示程序头表。
-S：显示节区头表。
-s：显示符号表。
-r：显示重定位信息。
-d：显示动态段信息。
-a：显示所有信息（相当于多个选项的组合）。
-V：显示版本信息。

## objdump

`objdump` 是一个强大的命令行工具，通常用于分析目标文件（如 `.o` 文件）、可执行文件和库文件。它提供了多种功能，包括反汇编、查看符号表和显示文件头信息等。

### 常用选项和功能

1. **反汇编**：

   - `-d`：反汇编所有可执行代码段。

     ```bash
     objdump -d file.o
     ```

2. **显示符号表**：

   - `-t`：显示符号表中的符号信息。

     ```bash
     objdump -t file.o
     ```

3. **显示文件头信息**：

   - `-f`：显示文件格式和目标文件的头信息。

     ```bash
     objdump -f file.o
     ```

4. **显示段信息**：

   - `-h`：显示目标文件的段和节的信息。

     ```bash
     objdump -h file.o
     ```

5. **显示调试信息**：

   - `-S`：同时显示源代码和反汇编。

     ```bash
     objdump -S file.o
     ```

6. **分析特定段**：

   - `-s`：显示指定段的原始内容。

     ```bash
     objdump -s -j .text file.o
     ```

7. **显示架构信息**：

   - `-A`：显示目标文件的所有架构信息。

     ```bash
     objdump -A file.o
     ```

8. 显示行号

   - `-l`：显示目标文件或可执行文件的行号信息。

     ```bash
     objdump -l file.o
     ```

     输出通常包括各个源文件及其对应的行号，以及在目标文件中对应的地址。为了正确显示行号信息，编译源代码时需要使用调试信息选项（如 `-g`）。如果目标文件没有包含调试信息，`-l` 选项可能不会提供有效的输出。

### 示例

1. 从 so 反汇编

   ```bash
   objdump -d -S -l xx.o > xx.s
   ```

**适用范围**：

`objdump` 适用于多种操作系统和处理器架构，包括 Linux 和 Windows 下的 ELF 和 PE 格式文件。它是调试和优化程序的重要工具，尤其在逆向工程和性能分析中非常有用。

# 编译工具

## make

make 命令是一个用于自动化编译和构建项目的工具，通常会根据一个名为 Makefile 的文件来执行编译、链接等相关操作。

当你执行 make 命令时，如果**不指定要编译的目标文件**，它会**按顺序**查找如下两个文件 `Makefile` 和 `makefile`：

- `Makefile` 是最常见的文件名，大小写敏感，通常首字母大写。
- `makefile` 是另一个常见的文件名，首字母小写。

如果找到了 `Makefile`，则会执行它；如果找不到 `Makefile`，它会尝试查找 `makefile`。

可以使用 `-f` 选项**指定特定的编译的目标文件**，如 `make -f custom_makefile`，将会强制 make 使用 `custom_makefile` 而不是默认的 `Makefile` 或 `makefile`。

执行步骤：

1. **读取 `Makefile`**：make 会读取当前目录下的 Makefile 或 makefile。
2. **寻找默认目标**：make 会执行 Makefile 中的第一个目标，通常称为 默认目标。
3. **递归构建**：如果默认目标依赖于其他目标，make 会首先递归构建这些依赖的目标。

示例：
假设你有一个简单的 Makefile，内容如下：

```makefile
all: main.o utils.o
    gcc -o my_program main.o utils.o

main.o: main.c
    gcc -c main.c

utils.o: utils.c
    gcc -c utils.c
```

当你运行 make 时，make 会执行以下操作：

查找 Makefile 或 makefile 文件。
执行默认目标 all，这将触发对 main.o 和 utils.o 的构建。
根据规则，它会先检查 main.o 是否存在，如果不存在或文件已更改，会重新编译 main.c。
同样地，对 utils.o 进行检查和编译。
最终生成目标 my_program。

### 常用选项

`make` 是一个用于自动化编译和构建项目的工具，它通过一个名为 `Makefile` 的文件来定义规则和依赖关系，以自动化项目的编译、链接等过程。以下是 `make` 常用的一些选项及其介绍：

1. **`-f`**
   **用法**：`make -f <Makefile>`
   **描述**：指定一个自定义的 `Makefile` 文件。如果当前目录下没有名为 `Makefile` 的文件或需要使用不同的文件时，可以使用此选项。
2. **`-j`**
   **用法**：`make -j [N]`
   **描述**：并行执行多个任务。`N` 表示并行执行的任务数。如果省略 `N`，`make` 将根据系统资源决定可以同时运行多少任务。这个选项可以加快编译速度，特别是在多核处理器的机器上。
3. **`-k`**
   **用法**：`make -k`
   **描述**：即使某个目标构建失败，继续尝试构建其他目标。`k` 代表 "keep going"。
4. **`-s`**
   **用法**：`make -s`
   **描述**：安静模式，禁止 `make` 打印命令的执行信息，只输出错误或重要信息。
5. **`-B`**
   **用法**：`make -B`
   **描述**：强制重新构建所有目标文件，不论是否已经是最新的。这在某些依赖关系复杂的项目中可能非常有用。
6. **`-n`**
   **用法**：`make -n`
   **描述**：仅打印出需要执行的命令，但并不实际执行它们。这对于调试 `Makefile` 很有帮助。
7. **`-C`**
   **用法**：`make -C <dir>`
   **描述**：切换到指定目录 `<dir>` 下执行 `Makefile`。适用于递归构建子目录项目。
8. **`-t`**
   **用法**：`make -t`
   **描述**：更新目标文件的时间戳，而不实际编译。这可以让 `make` 认为目标文件是最新的，避免再次编译。
9. **`-p`**
   **用法**：`make -p`
   **描述**：打印 `make` 的内部数据库，包括变量和目标的定义。这可以帮助分析和调试 `Makefile`。
10. **`-q`**
    **用法**：`make -q`
    **描述**：查询模式，不实际执行任何命令，只判断目标是否需要重新构建。如果不需要重新构建，返回状态为 0，若需要则返回非零状态。
11. **`-v`**
    **用法**：`make -v`
    **描述**：打印 `make` 的版本信息。
12. **`--help`**
    **用法**：`make --help`
    **描述**：显示 `make` 的帮助信息，列出所有可用选项及简要说明。

**使用示例**：

```bash
# 使用 Makefile 编译项目
make

# 并行执行 4 个任务
make -j 4

# 使用自定义的 MyMakefile 文件
make -f MyMakefile

# 调试 Makefile，只打印命令不执行
make -n

# 强制重新编译所有目标
make -B
```

这些选项可以帮助你更高效地使用 `make` 来管理项目的构建流程。

## cmake

> 参考资料：
> [1]. [cmake 实践](https://cmake.readthedocs.io/en/latest/1.html) > [2]. [CMake 教程 | CMake 从入门到应用](<[123](https://aiden-dong.github.io/2019/07/20/CMake%E6%95%99%E7%A8%8B%E4%B9%8BCMake%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BA%94%E7%94%A8/)>)

在 CMake 中，`-D` 选项设置的变量**优先级高于** `CMakeLists.txt` 中使用 `set` 命令设置的变量。你通过命令行使用 `-D` 选项设置变量时，CMake 会在项目的配置阶段立即读取这些值并将它们赋给相应的变量。这些命令行定义的变量会覆盖在 `CMakeLists.txt` 文件中通过 `set` 定义的相同变量。

这种设计使得在配置构建时，可以灵活地通过命令行设置变量的值，而不需要修改源代码中的 CMake 文件。这在构建不同配置（如调试、发布等）时非常方便。

### 常用选项

在 CMake 中，选项和变量之间的空格使用规则主要取决于命令和参数的具体形式。下面将详细说明这些规则，以帮助你更好地理解它们之间的区别。

**选项和命令参数的空格**:

在 CMake 命令中，选项通常是以单破折号（`-`）或双破折号（`--`）开头的字母或单词。
**单个选项形式通常没有空格**，如：`cmake -DVARIABLE=value ..`，有空格也合法但不推荐，如：`cmake -D VARIABLE=value ..`。
**长选项形式必须有空格**，如：`cmake --build ./build`。

**CMake 中常用的一些选项**：

1. `-D` 选项: 定义或设置变量

   - **用途**: 在命令行中定义或设置 CMake 变量。

   - **用法**: `cmake -D<variable>=<value> ..`

   - **作用**: 用于在配置过程中指定 CMakeLists.txt 文件中的变量的值。变量可以是用于控制编译选项、启用/禁用功能等。

   - **示例**:

     ```bash
     cmake -D CMAKE_BUILD_TYPE=Release ..
     cmake -D BUILD_TESTS=ON ..
     ```

     这会将 `CMAKE_BUILD_TYPE` 设置为 `Release` 模式，并启用 `BUILD_TESTS` 选项。

2. `-U` 选项: 删除缓存中的变量

   - **用途**: 从 CMake 缓存中删除变量。

   - **用法**: `cmake -U <variable> ..`

   - **作用**: 用于清理已定义的变量。变量通常存储在 `CMakeCache.txt` 文件中，有时需要移除缓存的变量以防止使用过时的值。

   - **示例**:

     ```bash
     cmake -U MY_OLD_VARIABLE ..
     ```

     这将从缓存中删除 `MY_OLD_VARIABLE`。

3. `-S` 选项: 指定源目录

   - **用途**: 指定源代码的根目录。

   - **用法**: `cmake -S <source_dir>`

   - **作用**: 用于显式指定包含 `CMakeLists.txt` 文件的目录。如果不指定，CMake 会假设你当前的工作目录就是源目录。

   - **示例**:

     ```bash
     cmake -S /home/user/my_project
     ```

     这将把 `/home/user/my_project` 作为 CMake 项目的源代码目录。

4. `-B` 选项: 指定构建目录

   - **用途**: 指定构建输出的目录。

   - **用法**: `cmake -B <build_dir>`

   - **作用**: 指定构建文件的输出路径。这可以帮助你将生成的文件（例如 Makefile、Visual Studio 解决方案等）与源代码分开存放。

   - **示例**:

     ```bash
     cmake -S /home/user/my_project -B /home/user/my_project/build
     ```

     这将使用 `/home/user/my_project` 作为源目录，并将生成的构建文件放入 `/home/user/my_project/build` 目录。

5. `-C` 选项: 预加载脚本

   - **用途**: 预加载一个 CMake 脚本，该脚本将首先被执行。

   - **用法**: `cmake -C <initial_cache>`

   - **作用**: 用于在项目配置之前加载某个特定的预配置变量或设置。

   - **示例**:

     ```bash
     cmake -C /path/to/preset_config.txt ..
     ```

6. `-G` 选项: 指定生成器

   - **用途**: 指定构建系统生成器（例如 Makefile、Visual Studio 工具集等）。

   - **用法**: `cmake -G <generator_name>`

   - **作用**: CMake 可以生成不同构建系统的文件，如 Unix Makefiles 或 Visual Studio 项目文件。此选项用于指定目标生成器。

   - **示例**:

     ```bash
     cmake -G "Unix Makefiles" ..
     cmake -G "Visual Studio 16 2019" ..
     ```

7. `-P` 选项: 运行 CMake 脚本

   - **用途**: 运行一个特定的 CMake 脚本，而不是配置项目。

   - **用法**: `cmake -P <script_file>`

   - **作用**: 如果你编写了一个包含 CMake 指令的脚本，可以使用 `-P` 运行它。该模式**主要用于执行非配置操作，比如自定义的安装步骤**。

   - **示例**:

     ```bash
     cmake -P my_custom_script.cmake
     ```

8. `-L` 选项: 列出缓存变量

   - **用途**: 列出所有的 CMake 缓存变量及其值。

   - **用法**: `cmake -L ..`

   - **作用**: 打印 CMakeCache.txt 中变量及其值，便于调试和查看当前配置的状态。`cmake -L ..` 默认只打印 **非高级** 的缓存变量（即那些通常直接控制项目配置的变量）。高级变量则不会默认显示。高级变量可以是某些库的路径、编译器标志等，在不启用高级模式下不会列出。

   - **示例**:

     ```bash
     cmake -L .. # 只打印 **非高级** 的缓存变量
     cmake -LA .. # 显示高级变量
     cmake -LAH .. # 显示高级变量，并为每个变量提供简短描述
     ```

     - `-L`：列出所有非高级变量。即那些通常直接控制项目配置的变量。
     - `-A`：显示高级变量。
     - `-H`：为每个变量提供简短描述。

9. `--build` 选项: 执行构建

   - **用途**: 使用 CMake 来执行项目的实际构建。

   - **用法**: `cmake --build <build_dir>`

   - **作用**: 在指定的构建目录中运行实际的构建过程。该选项可以替代直接使用如 `make` 或 `ninja` 等构建工具的调用。`cmake --build` 命令**依赖于 CMake 生成的构建文件**，例如 `Makefile` 或者 `ninja.build` 文件。如果这些文件没有生成，那么 `--build` 命令就无效。确保你已经成功运行 `cmake` 来生成构建文件。

   - **示例**:

     ```bash
     cmake --build /home/user/my_project/build --target all
     ```

     这将在 `/home/user/my_project/build` 中执行构建并构建所有目标。

10. `--install` 选项: 执行安装

    - **用途**: 安装已构建的项目。

    - **用法**: `cmake --install <build_dir>`

    - **作用**: 按照项目配置文件中的安装指令（如 `install()` 指令）来安装构建结果。

    - **示例**:

      ```bash
      cmake --install /home/user/my_project/build
      ```

11. `--target` 选项: 构建指定的目标

    - **用途**: 构建特定的目标。

    - **用法**: `cmake --build <build_dir> --target <target_name>`

    - **作用**: 用于在构建过程中指定某个特定的目标，而不是默认的全部目标。例如，你可以仅构建单元测试或特定的库。

    - **示例**:

      ```bash
      cmake --build /home/user/my_project/build --target test
      ```

**组合使用示例**：

```bash
cmake -S /home/user/my_project -B /home/user/my_project/build -D CMAKE_BUILD_TYPE=Release -D BUILD_SHARED_LIBS=ON
cmake --build /home/user/my_project/build --target all
```

这个命令会在 `/home/user/my_project/build` 目录下进行构建，使用 `Release` 模式，并且启用共享库的构建选项。

### 常用变量

1. `CMAKE_CURRENT_SOURCE_DIR`：当前处理的 CMakeLists.txt 所在的路径
2. ``：

### 常用指令

#### `set`

`set` 用来显式的定义变量。

```cmake
SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])
```

#### `file`

`file` 用于处理文件系统相关的操作。它可以执行多种文件操作，包括复制文件、删除文件、读取内容、写入内容等。

#### `target_compile_options`

`target_compile_options` 是 CMake 中用于设置编译选项的命令，它可以为特定的目标（如可执行文件或库）指定编译器标志。这些编译选项会在编译目标时传递给编译器，以影响生成的代码行为、优化等级、警告级别等。

**主要用途**：

- **为目标指定编译选项**：可以将不同的编译选项应用于不同的目标，使每个目标的编译配置更加灵活和独立。
- **设置编译器相关标志**：支持根据编译器类型设置不同的选项，适配多种编译器（如 GCC、Clang、MSVC）。
- **控制编译选项的作用域**：支持设置编译选项的作用域，指定选项是否仅对目标自身生效，还是对目标的依赖项也生效。

**参数说明**：

```cmake
target_compile_options(<target> <INTERFACE|PUBLIC|PRIVATE> [options...])
```

- `<target>`：指定要添加编译选项的目标。

- `<INTERFACE|PUBLIC|PRIVATE>`：控制编译选项的作用范围。

  - **PRIVATE**：仅在指定的目标内部使用这些选项。
  - **PUBLIC**：在指定目标和依赖于该目标的其他目标中使用。
  - **INTERFACE**：仅在依赖于该目标的其他目标中使用，而不会应用在自身的编译中。

**示例 1**：

假设有一个可执行文件 `my_program`，要为其设置不同的编译选项：

```cmake
add_executable(my_program main.cpp)

# 添加编译选项
target_compile_options(my_program PRIVATE -Wall -O2)
```

在这个示例中：

- `-Wall`：启用所有警告。
- `-O2`：设置优化等级为 `O2`，开启中等优化。

**示例 2**：

可以根据编译器类型来设置选项，避免不兼容的选项错误：

```cmake
if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    target_compile_options(my_program PRIVATE -Wall -Wextra)
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    target_compile_options(my_program PRIVATE /W4)
endif()
```

这样，`target_compile_options` 可以灵活地适应不同的编译器需求，为项目的特定目标配置合适的编译选项。

# 编译选项

## 编译取消内联

在 C++ 中，内联（inline）是一种编译优化技术，编译器会尝试将函数的代码直接嵌入调用点以减少函数调用开销。但有时我们可能希望取消内联，以方便调试或避免不必要的代码膨胀。

以下是一些方法可以阻止或限制编译器对函数进行内联：

### 代码层面取消内联

1. **取消 `inline` 关键字**

   如果代码中使用了 `inline` 关键字，可以去掉它，告诉编译器不要内联该函数，但编译器还可能自动内联：

   ```cpp
   void myFunction();  // 不加 inline
   ```

   > 即使不使用 inline 关键字，编译器在开启内联优化的情况下，仍然可能会自动选择一些函数进行内联。编译器在决定是否内联时，会根据函数的大小、调用频率以及复杂性等因素进行判断。现代编译器（如 GCC、Clang 和 MSVC）都有这样的功能，可以在不依赖 inline 关键字的情况下进行自动内联，以提高性能。

2. **某些编译器允许使用特定的属性来取消内联**

   取消内联的特定属性有：`__attribute__((noinline))` 或 `__declspec(noinline)`。

   - **GCC / Clang**：使用 `__attribute__((noinline))`

     ```cpp
     void myFunction() __attribute__((noinline));
     ```

   - **MSVC**：使用 `__declspec(noinline)`

     ```cpp
     __declspec(noinline) void myFunction();
     ```

   > 如果在代码中对特定函数使用 `__attribute__((noinline))` 属性，那么即使编译器的内联优化选项开启，**该函数依然不会被内联**。这是因为 `__attribute__((noinline))` 明确指示编译器**绝对不要对这个函数进行内联**，无论是否启用了内联优化。
   >
   > **具体情况说明**：
   >
   > 1. **`__attribute__((noinline))` 优先级更高**：该属性强制指定了不允许内联，所以编译器会忽略任何内联相关的编译选项（如 `-O2`, `-O3`, `-finline-functions`）对这个函数的影响。
   > 2. **作用于特定函数**：`__attribute__((noinline))` 仅作用于标注了该属性的函数，不会影响其他未标注的函数。即使其他函数可能会在开启优化时被自动内联，带有 `noinline` 属性的函数也会保持不内联。
   > 3. **跨平台适用性**：这个属性在 GCC 和 Clang 编译器中均可用，MSVC 中可以用 `__declspec(noinline)` 达到相同效果。

### 编译器层面取消内联

#### 使用编译器选项

在 C++ 中，可以通过一些编译选项来禁止内联优化。不同的编译器提供了各自的选项来关闭内联：

1. **GCC 和 Clang**

   - `-fno-inline`：禁用所有内联优化，包括显式的 `inline` 关键字函数和编译器自动内联的函数。

     ```bash
     g++ -fno-inline -o my_program my_program.cpp
     ```

   - `-fno-inline-functions`：仅禁止编译器自动内联函数，但显式 `inline` 关键字的函数仍可能被内联。

     ```bash
     g++ -fno-inline-functions -o my_program my_program.cpp
     ```

   - `-fno-inline-small-functions`：禁止对小函数的内联优化。

   - `-fno-default-inline`：禁用类成员函数的隐式内联，通常用于定义在类内部的成员函数。

2. **MSVC（Microsoft Visual C++）**

   - `/Ob0`：禁止所有内联优化，包括显式 `inline` 关键字的函数和自动内联。

     ```bash
     cl /Ob0 my_program.cpp
     ```

   在这些选项的帮助下，编译器将不再对代码进行内联优化，有助于调试或控制编译输出的大小。

#### cmake 禁用内联

在 CMake 中，可以通过设置编译器的选项来禁用内联。不同的编译器有不同的标志，用 CMake 配置来适配这些编译器标志可以达到禁用内联的效果。

**CMake 配置示例**：

可以在 `CMakeLists.txt` 中使用 `target_compile_options` 添加编译选项，禁用内联：

```cmake
project(MyProject)

# 添加源码文件
add_executable(my_program main.cpp)

# 检测编译器并添加相应的禁用内联的选项
if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" OR CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
    target_compile_options(my_program PRIVATE -fno-inline -fno-inline-functions)
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    target_compile_options(my_program PRIVATE /Ob0)
endif()
```

**说明**：

- **GCC / Clang**：使用 `-fno-inline` 和 `-fno-inline-functions` 选项来禁用内联。
- **MSVC**：使用 `/Ob0` 禁用所有内联优化。

通过这种方式，可以在 CMake 中自动根据编译器来选择禁用内联的适合选项。

## 优化级别 `O0~O3`

编译器的优化选项用于提高程序的执行效率和减少生成代码的大小。不同的优化级别会影响编译过程中的优化策略。以下是常见的优化选项及其特点：

### 常见优化选项

1. **`-O0`**：
   - **描述**：无优化。默认情况下，编译器会生成易于调试的代码。
   - **适用场景**：用于调试阶段，以便能够准确跟踪源代码与生成代码之间的关系。
2. **`-O1`**：
   - **描述**：启用基本优化。会进行一些简单的优化，但不会显著增加编译时间。
   - **适用场景**：在开发和调试时，适当提高性能，而又不增加过多的编译时间。
3. **`-O2`**：
   - **描述**：启用较全面的优化。包括更多的优化策略，如代码重排、消除冗余代码等，通常能显著提高程序性能。
   - **适用场景**：适用于需要较高性能的生产代码，通常是推荐的优化级别。
4. **`-O3`**：
   - **描述**：启用最高级别的优化。除了 `-O2` 的所有优化外，还会包括更激进的优化策略，如循环展开和矢量化。
   - **适用场景**：适用于性能要求极高的应用程序，尤其是在科学计算或大型数据处理时，但可能会增加编译时间和可执行文件的大小。
5. **`-Ofast`**：
   - **描述**：启用所有 `-O3` 的优化，并且忽略某些标准兼容性，如浮点数的精度。
   - **适用场景**：在追求极限性能的情况下，可以牺牲一些精度和标准兼容性。

### 其他相关选项

- **`-Os`**：优化以减小代码大小，通常用于内存受限的环境。
- **`-Oz`**：更激进地优化以减小代码大小，可能会比 `-Os` 产生更小的代码。
- **`-flto`**：启用链接时间优化（LTO），可以在链接阶段进行额外优化，提高性能。

### 设置命令

在 CMake 中设置优化级别为 `O1`，你可以通过 `CMAKE_CXX_FLAGS` 或 `target_compile_options` 来设置编译选项。具体方法如下：

**方法 1: 通过 `CMAKE_CXX_FLAGS` 设置**：

在你的 `CMakeLists.txt` 文件中，可以通过设置 `CMAKE_CXX_FLAGS` 来指定优化级别。

```cmake
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O1")
```

**方法 2: 通过 `target_compile_options` 设置**：

如果你只想为特定的目标（例如某个可执行文件或库）设置优化级别，可以使用 `target_compile_options` 来指定：

```cmake
target_compile_options(your_target_name PRIVATE -O1)
```

**注意事项**：

- **调试信息**：较高的优化级别可能会导致源代码与调试信息不一致，从而影响调试体验。
- **性能测试**：不同的代码可能在不同的优化级别下表现不同，因此在选择优化级别时，最好进行性能测试。

# 常见编译问题

## 确认 so 库是否包含调试信息

在 Linux 下，可以通过以下几种方法确认一个共享库（`.so` 文件）是否包含调试信息：

### 使用 `file` 命令

`file` 命令可以快速查看 `.so` 文件的一些基本信息，包括它是否包含调试信息。

```bash
file /path/to/library.so
```

```bash
libmylib.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked,
for GNU/Linux 3.2.0, BuildID[sha1]=1abc2def3, not stripped
```

- 如果输出中包含 **"not stripped"**，则说明文件没有被剥离符号信息，可能包含调试符号。
- 如果显示 **"stripped"**，则表示符号信息已经被移除，不包含调试符号。

### 使用 `readelf` 命令

`readelf` 是一个强大的工具，可以查看 ELF 文件（包括共享库）的详细信息。你可以使用它来查看文件是否包含 `.debug_*` 段，这些段通常包含调试信息。

```bash
readelf --sections /path/to/library.so | grep debug
# 或
readelf -S /path/to/your/library.so | grep debug
```

```bash
  [25] .debug_info       PROGBITS        0000000000000000  000020e0
  [26] .debug_abbrev     PROGBITS        0000000000000000  000021d8
  [27] .debug_aranges    PROGBITS        0000000000000000  00002228
  [28] .debug_line       PROGBITS        0000000000000000  000022a0
  [29] .debug_str        PROGBITS        0000000000000000  00002338
```

如果输出中有类似 `.debug_info`、`.debug_line`、`.debug_str` 等段，说明该库包含调试信息。

### 使用 `objdump` 命令

`objdump` 可以提供关于 ELF 文件的详细信息，并且可以检查符号是否包含调试信息。

```bash
objdump -h /path/to/library.so | grep debug
```

如果库中包含调试信息段，输出会显示类似 `.debug_*` 的符号。

### 在 GDB 中确认

你可以在 GDB 中加载 `.so` 文件，然后查看该库是否包含调试符号。

```bash
gdb /path/to/executable
(gdb) info sharedlibrary
```

或者直接使用 `info functions` 来查看某个 `.so` 文件中的函数符号。

### 查询是否有外部调试符号文件

有些 Linux 系统会将调试符号从 `.so` 文件中分离出来，存储在单独的 `.debug` 文件中。可以使用 `debuginfo` 或 `debuginfod` 来加载这些调试符号。确保你已经安装了调试符号包，例如 `libc6-dbg`。

如果是用包管理工具安装的库，可以用如下命令检查是否存在调试符号包：

```bash
dpkg -l | grep dbg  # For Debian/Ubuntu systems
rpm -qa | grep dbg  # For RedHat/Fedora systems
```

通过这些方法，你可以有效地确认一个 `.so` 文件是否包含调试信息。如果发现调试符号被剥离，你可能需要重新编译该库，确保使用 `-g` 选项，或者安装相应的调试符号包。

## 确保库包含调试符号

若 CMake 编译的 `.so` 库包含不包含调试符号，可进行如下检查：

### 设置 CMake 构建类型

在执行 **CMake 命令**时，确保设置构建类型为 `Debug`。可以使用以下参数：

```bash
-D CMAKE_BUILD_TYPE=Debug
```

### 使用调试编译选项

在**执行 CMake 脚本**时，即 `CMakeLists.txt` 中，可以添加以下选项，以确保生成调试符号：

```cmake
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g") # C++
set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -g") # C
```

### 移除剥离符号的选项

检查**编译选项**，确保 `CMakeLists.txt` 中没有使用 `-s` 或其他会剥离调试信息的标志。如下面**剥离符号**的设置：

```cmake
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -s")
```

检查**链接选项**，确保没有使用 `-s` 或其他会剥离调试信息的标志。具体地，避免在 `LOPTS` 中添加 `-s`，如下所示：

```cmake
LOPTS
    # -s  # 移除这一行
```

### 确保依赖库也包含调试符号

如果你的 `.so` 库依赖其他库，确保这些库也以 `Debug` 模式编译并包含调试符号。

### 使用适当的编译器

确保使用支持调试符号的编译器（例如 GCC 或 Clang），并且其版本能够正确处理 `-g` 选项。

示例 CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.10)
project(my_library)

set(CMAKE_BUILD_TYPE Debug)

add_library(my_shared_library SHARED
    source1.cpp
    source2.cpp
)

set_target_properties(my_shared_library PROPERTIES
    COMPILE_FLAGS "-g"
    LINK_FLAGS ""  # 确保不剥离符号
)
```

### 总结

- 使用 `-DCMAKE_BUILD_TYPE=Debug`。
- 添加 `-g` 选项以确保生成调试符号。
- 移除编译时/链接时剥离符号的选项。
- 确保所有依赖库也包含调试符号。

# 调试经验

## core dump

导致程序发生**core dump**（核心转储）的原因主要是由于程序在运行时发生了非法的内存访问或者其它不可恢复的错误。具体来说，以下是一些常见原因：

1. **空指针解引用**：访问未初始化或已被释放的指针，导致程序尝试访问不存在的内存区域。
2. **数组越界**：访问数组边界之外的元素，导致程序读取或写入非预期的内存位置。
3. **堆内存溢出**：程序在堆上分配内存时申请超过可用内存范围，导致无法分配。
4. **栈内存溢出**：通常由递归层数过深、局部变量申请内存过多等原因导致。
5. **非法内存访问**：尝试访问已经释放的内存（如释放后再次使用），或访问未申请的内存区域。
6. **内存对齐错误**：某些架构中，不按照对齐要求访问内存会触发异常。
7. **未捕获的异常**：如果使用 C++ 编程语言，未捕获的异常会导致程序崩溃，进而触发 core dump。
8. **系统资源限制**：系统设置了内存使用的限制，当进程的资源需求超出上限时会导致崩溃。

通过调试工具（如 `gdb`）查看 core dump 文件，可以分析出导致程序崩溃的具体原因，并针对性地优化代码。

## gdb 调试 core dump 文件

使用 `gdb` 查看 core dump 文件是调试程序崩溃的一个有效方法。以下是如何用 `gdb` 来分析 core dump 并定位错误的步骤和示例。

### 基本步骤

1. **生成 core dump 文件**：

   - 确保系统允许生成 core dump 文件。在 Linux 下可以使用以下命令：

     ```bash
     ulimit -c unlimited  # 允许生成 core dump 文件
     ```

   - 运行崩溃的程序，当它崩溃时会生成一个名为 `core` 的 core dump 文件（或者 `core.<PID>` 这样的文件，具体取决于系统配置）。

2. **使用 gdb 调试 core dump 文件**：

   ```bash
   gdb <程序名> <core文件>
   ```

   其中，`<程序名>` 是崩溃的可执行程序的路径，`<core文件>` 是生成的 core dump 文件路径。这样就可以把程序和 core dump 文件一同载入 `gdb`。

3. **定位问题**：

   - 使用 `bt`（backtrace）命令查看调用栈，从而定位崩溃点。
   - 使用其他调试命令，如 `list` 查看代码行，`print` 查看变量值等。

### 示例

假设有一个简单的 C++ 程序 `example.cpp`，代码如下：

```cpp
#include <iostream>

void foo() {
    int *ptr = nullptr;  // 指针未初始化
    *ptr = 42;           // 尝试解引用空指针
}

int main() {
    foo();
    return 0;
}
```

编译并运行该程序：

```bash
g++ -g -o example example.cpp
./example
```

程序会崩溃，并生成 core dump 文件（**假设名为 `core`**）。

**使用 gdb 分析 core dump**：

1. **打开 gdb**：

   ```bash
   gdb ./example core
   ```

2. **查看崩溃位置**： 进入 `gdb` 后，使用 `bt` 命令查看调用栈：

   ```gdb
   (gdb) bt
   #0  0x0000000000401142 in foo() at example.cpp:5
   #1  0x0000000000401153 in main() at example.cpp:9
   ```

   这里可以看到崩溃发生在 `foo()` 函数的第 5 行，即 `*ptr = 42;`，这是因为 `ptr` 是一个空指针。

3. **进一步检查**：

   - 使用 `list` 查看崩溃点附近的代码：

     ```gdb
     (gdb) list
     ```

   - 使用 `print` 查看指针 `ptr` 的值，以确认其是否为 `nullptr`：

     ```gdb
     (gdb) print ptr
     $1 = (int *) 0x0
     ```

这样可以明确地定位到程序崩溃的原因是在空指针 `ptr` 上进行解引用操作。通过这种方法可以帮助定位崩溃原因并修复代码。
