### IDM 绿色版下载
http://www.aichunjing.com/soft/2018-06-09/193.html

### C++11强类型枚举
https://blog.csdn.net/u012333003/article/details/20612267

https://www.cnblogs.com/Braveliu/p/12246219.html

### C++ 编译器提供的合成默认构造函数详解
https://www.huaweicloud.com/articles/be6e2bacf6b0b0fcae8db221d8ee7854.html

### C语言宏定义中#和##的作用
https://www.huaweicloud.com/articles/fc726b7cd31c34e42f20a945e695328d.html

### 华强北耳机声音大
https://g.penzai.com/%E5%8D%8E%E5%BC%BA%E5%8C%97%E8%80%B3%E6%9C%BA%E5%A3%B0%E9%9F%B3%E5%A4%A7.html

### C++中的函数重载中为什么不考虑返回值类型？
https://blog.csdn.net/kuweicai/article/details/68927711

### git 切换分支时会把未add或未commit的内容带过去
https://blog.csdn.net/stpeace/article/details/84351160
https://blog.csdn.net/Chandler_Z/article/details/108989886?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242.0

https://blog.csdn.net/qfc8930858/article/details/80957329?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&spm=1001.2101.3001.4242.0

https://blog.csdn.net/qq_26079093/article/details/96098950?spm=1001.2101.3001.6650.1&utm_medium=distribute.wap_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1.withoutpaiwithsearchfrombaidu_wap&depth_1-utm_source=distribute.wap_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1

https://segmentfault.com/a/1190000023734704

### git 放弃修改，放弃增加文件操作
https://blog.csdn.net/ustccw/article/details/79068547

### 7.14 Git 工具 - 凭证存储
https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8
如果大家使用http协议向fetch或push私有库（或push公有库）的话，命令行（或其他git工具）会提示输入用户名和密码，每次这样做都很麻烦，那设置下git证书缓存就好了。
这里默认大家安装的都是git 1.8.1及以上版本（git --version可以查看版本号），如果低于此版本的建议升级Git或上网找方法。
在Git Bash上执行即可：
git config --global credential.helper wincred
然后使用http协议操作仓库时输入一次用户名密码就会被缓存起来，后面就不需要重复输入了。

### Git 实用技巧 - 配置 credential.helper
https://zihengcat.github.io/2017/08/26/git-practical-tips-config-credential-helper/

### sizeof(i++)是多少？
https://blog.csdn.net/FX677588/article/details/77151014

### 迭代器
http://c.biancheng.net/view/338.html

### C中的宏的使用(宏嵌套/宏展开/可变参数宏)
https://blog.csdn.net/weixin_34242509/article/details/91879470?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link

https://blog.csdn.net/Pillary/article/details/53705158

### 关于传值与传引用的讨论
https://www.cnblogs.com/QG-whz/p/5129173.html

### 【Linux】GDB用法详解(5小时快速教程)
https://www.cnblogs.com/lvdongjie/p/8994092.html

### C++顶层const和底层const的区别
https://blog.csdn.net/yangyong0717/article/details/73655709

### 彻底搞懂函数重载匹配
https://zhuanlan.zhihu.com/p/53874619

### 指针数组、数组指针


### Malloc函数的线程安全与可重入性分析
https://blog.csdn.net/weiganyi/article/details/11142347

### C + + 内置运算符、优先级和结合性
https://docs.microsoft.com/zh-cn/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-160

### static、static inline、static const

### C++多态--虚函数virtual及override
https://blog.csdn.net/i_chaoren/article/details/77281785

### C++ 异常
https://www.cnblogs.com/nzbbody/p/3418989.html

### C++ 初始化列表的初始化顺序
https://www.shuzhiduo.com/A/q4zVkbybJK/

### git的4个阶段的撤销更改
https://www.jianshu.com/p/22068769c2f0

### /C++ - 类中成员变量是引用
https://blog.csdn.net/lazyq7/article/details/48186291

### git pull报错: The following untracked working tree files would be overwritten by merge：
https://www.cnblogs.com/objectZhu/p/13205803.html

https://blog.csdn.net/allanGold/article/details/79213606

### leetcode 排名
https://zerotrac.github.io/leetcode_problem_rating/
算法训练的内卷，过两年可能要去codeforces，Topcoder上面进口题目了

### 30张图带你彻底理解红黑树
https://www.jianshu.com/p/e136ec79235c
https://zhuanlan.zhihu.com/p/31805309

### Excel把行高和列宽单位设置成厘米,精确设置表格
https://github.com/chaorancui/temp/edit/main/%E7%BD%91%E5%9D%80.md


#include <algorithm>
#include <cmath>
#include <iostream>
#include <map>
#include <sstream>
#include <string>
#include <vector>

using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// 由数组构建完全/满二叉树
TreeNode *constructBinaryTree(const vector<string> &vecstr, int i)
{
    if (vecstr.empty())
        return nullptr; // 特殊情况处理
    if (i >= vecstr.size())
        return nullptr;
    TreeNode *root = nullptr;
    if (vecstr[i] != "null") {
        root = new TreeNode(stoi(vecstr[i]));
        root->left = constructBinaryTree(vecstr, 2 * i + 1);
        root->right = constructBinaryTree(vecstr, 2 * i + 2);
    }
    return root;
}

class Solution {
public:
    map<int, int> mapDepth;
    vector<int> depth;
    int cnt = 1;
    // void getDepth(TreeNode *root) {
    //   if (root == nullptr) return;
    //   depth.push_back(cnt);
    //   cnt++;
    //   getDepth(root->left);
    //   getDepth(root->right);
    //   cnt--;
    // }

    void getDepth(TreeNode *root, int cntDepth)
    {
        if (root == nullptr) {
            return;
        }
        // mapDepth[root->val] = max(mapDepth[root->val], cntDepth); // 键值不存在，[]访问插入默认值；此处可用，不建议
        pair<map<int, int>::iterator, bool> ret = mapDepth.insert(pair<int, int>(root->val, cntDepth));
        // 已存在key，取最大val
        if (!ret.second) {
            (ret.first)->second = max((ret.first)->second, cntDepth);
        }
        getDepth(root->left, cntDepth + 1);
        getDepth(root->right, cntDepth + 1);
    }

    vector<int> ValueDepth(const vector<int> &target, const TreeNode *root)
    {
        if (!root) {
            return {};
        }
        // 一次反向遍历，获取key大于当前key的节点的最大深度值
        // for (auto it = mapDepth.rbegin() + 1; it != mapDepth.rend(); ++it) {
        //     it->second = max(it->second, (it + 1)->second);
        // }
        auto it = mapDepth.rbegin();
        for (auto it = mapDepth.rbegin() + 1; it != mapDepth.rend(); ++it) {
            // it->second = max(it->second, (it + 1)->second);
        }

        vector<int> retVec;
        for (const int &x : target) {
            retVec.push_back(mapDepth.lower_bound(x)->second);
        }
        return retVec;
    }

    int maxDepth(TreeNode *root)
    {
        if (!root) {
            return 0; // 特殊情况处理
        }
        getDepth(root, 1);
        sort(depth.begin(), depth.end(), less<int>());
        return depth.back();
    }
};

int main()
{
    Solution sol;

    stringstream sstr;
    sstr << "3,4,11,3,null,null,8,7,null,5";
    vector<string> vec;
    string s;
    while (getline(sstr, s, ',')) {
        vec.push_back(s);
    }
    for_each(vec.begin(), vec.end(), [](const string str) { cout << str << endl; });
    cout << "vec size: " << vec.size() << endl;
    int treeDepth = log2(vec.size() + 1);
    cout << "treeDepth: " << treeDepth << endl;

    TreeNode *root = constructBinaryTree(vec, 0); // 递归构建完全/满二叉树

    // sol.getDepth(root, 1);
    // cout << sol.maxDepth(root) << "====" << endl;
;
    sstr.clear();
    sstr << "6,2,9,7,9";
    vector<int> target;
    while (getline(sstr, s, ',')) {
        target.push_back(stoi(s));
    }
    for_each(target.begin(), target.end(), [](const int x) { cout << x << endl; });
    // vector<int> ans = sol.ValueDepth(target, root);
    // for_each(ans.begin(), ans.end(), [](const int x) { cout << x << endl; });
    return 0;
}










