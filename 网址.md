### IDM 绿色版下载
http://www.aichunjing.com/soft/2018-06-09/193.html

### C++11强类型枚举
https://blog.csdn.net/u012333003/article/details/20612267

https://www.cnblogs.com/Braveliu/p/12246219.html

### C++ 编译器提供的合成默认构造函数详解
https://www.huaweicloud.com/articles/be6e2bacf6b0b0fcae8db221d8ee7854.html

### C语言宏定义中#和##的作用
https://www.huaweicloud.com/articles/fc726b7cd31c34e42f20a945e695328d.html

### 华强北耳机声音大
https://g.penzai.com/%E5%8D%8E%E5%BC%BA%E5%8C%97%E8%80%B3%E6%9C%BA%E5%A3%B0%E9%9F%B3%E5%A4%A7.html

### C++中的函数重载中为什么不考虑返回值类型？
https://blog.csdn.net/kuweicai/article/details/68927711

### git 切换分支时会把未add或未commit的内容带过去
https://blog.csdn.net/stpeace/article/details/84351160
https://blog.csdn.net/Chandler_Z/article/details/108989886?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242.0

https://blog.csdn.net/qfc8930858/article/details/80957329?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&spm=1001.2101.3001.4242.0

https://blog.csdn.net/qq_26079093/article/details/96098950?spm=1001.2101.3001.6650.1&utm_medium=distribute.wap_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1.withoutpaiwithsearchfrombaidu_wap&depth_1-utm_source=distribute.wap_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1

https://segmentfault.com/a/1190000023734704

### git 放弃修改，放弃增加文件操作
https://blog.csdn.net/ustccw/article/details/79068547

### Git新命令switch和restore
https://yanhaijing.com/git/2020/09/17/git-switch-and-restore/

### Git 操作——如何删除本地分支和远程分支
https://chinese.freecodecamp.org/news/how-to-delete-a-git-branch-both-locally-and-remotely/

### 7.14 Git 工具 - 凭证存储
https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8
如果大家使用http协议向fetch或push私有库（或push公有库）的话，命令行（或其他git工具）会提示输入用户名和密码，每次这样做都很麻烦，那设置下git证书缓存就好了。
这里默认大家安装的都是git 1.8.1及以上版本（git --version可以查看版本号），如果低于此版本的建议升级Git或上网找方法。
在Git Bash上执行即可：
git config --global credential.helper wincred
然后使用http协议操作仓库时输入一次用户名密码就会被缓存起来，后面就不需要重复输入了。

### Git 实用技巧 - 配置 credential.helper
https://zihengcat.github.io/2017/08/26/git-practical-tips-config-credential-helper/

### Git-优雅地解决冲突：使用ours和theirs
https://blog.csdn.net/qq_41603165/article/details/104922336

### git pull --rebase 通过保持本地更改来解决冲突
https://www.coder.work/article/7575856

### 工具系列 | git checkout 可替换命令 git switch 和 git restore
https://www.cnblogs.com/tinywan/p/12344267.html

### git cherry-pick 教程
https://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html

### git rm问题
https://www.cnblogs.com/delav/p/8330507.html

### GIT如何查看本地分支与远程分支的关联配置（git branch --set-upstream）
https://blog.csdn.net/weixin_34410662/article/details/91817596

### GIT库中禁止追踪文件变化的两种方式
https://www.jianshu.com/p/cf9e8ca33e43
主题可以概括: 分布式环境下,自己忽略的文件如何不影响到他人
用.gitignore文件是不满足的,因为.gitignore文件也会随着仓库分发到他人那里
最好这个文件由自己掌控,那么不妨试试: git config --global core.excludesfile $yourfilepath

### sizeof(i++)是多少？
https://blog.csdn.net/FX677588/article/details/77151014

### 迭代器
http://c.biancheng.net/view/338.html

### C中的宏的使用(宏嵌套/宏展开/可变参数宏)
https://blog.csdn.net/weixin_34242509/article/details/91879470?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link

https://blog.csdn.net/Pillary/article/details/53705158

### 关于传值与传引用的讨论
https://www.cnblogs.com/QG-whz/p/5129173.html

### 【Linux】GDB用法详解(5小时快速教程)
https://www.cnblogs.com/lvdongjie/p/8994092.html

### C++顶层const和底层const的区别
https://blog.csdn.net/yangyong0717/article/details/73655709

### 彻底搞懂函数重载匹配
https://zhuanlan.zhihu.com/p/53874619

### 指针数组、数组指针


### Malloc函数的线程安全与可重入性分析
https://blog.csdn.net/weiganyi/article/details/11142347

### C + + 内置运算符、优先级和结合性
https://docs.microsoft.com/zh-cn/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-160

### static、static inline、static const

### C++多态--虚函数virtual及override
https://blog.csdn.net/i_chaoren/article/details/77281785

### C++ 异常
https://www.cnblogs.com/nzbbody/p/3418989.html

### C++ 初始化列表的初始化顺序
https://www.shuzhiduo.com/A/q4zVkbybJK/

https://zhuanlan.zhihu.com/p/268894227

https://blog.css8.cn/post/20448048.html

https://wendeng.github.io/2019/05/19/c++%E5%9F%BA%E7%A1%80/c++11%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/

### C++11智能指针：unique_ptr
https://www.jianshu.com/p/6764d28edafd

https://blog.csdn.net/shaosunrise/article/details/85158249

### Effective 转向现代C++
https://kafuu.cc/post/AuPMgwCJW/

### git的4个阶段的撤销更改
https://www.jianshu.com/p/22068769c2f0

### Git Reset 三种模式
https://www.jianshu.com/p/c2ec5f06cf1a

### /C++ - 类中成员变量是引用
https://blog.csdn.net/lazyq7/article/details/48186291

### git pull报错: The following untracked working tree files would be overwritten by merge：
https://www.cnblogs.com/objectZhu/p/13205803.html

https://blog.csdn.net/allanGold/article/details/79213606

### 如何规范你的Git commit？
https://zhuanlan.zhihu.com/p/182553920

### leetcode 排名
https://zerotrac.github.io/leetcode_problem_rating/
算法训练的内卷，过两年可能要去codeforces，Topcoder上面进口题目了

### 30张图带你彻底理解红黑树
https://www.jianshu.com/p/e136ec79235c
https://zhuanlan.zhihu.com/p/31805309

### Excel把行高和列宽单位设置成厘米,精确设置表格
https://github.com/chaorancui/temp/edit/main/%E7%BD%91%E5%9D%80.md

### YouTube
Costa Rica 4K Relaxing Music Along With Beautiful Nature Videos

### UML类图
https://www.cnblogs.com/swpu-zw/p/12489038.html

### 网址URL中特殊字符转义编码
https://blog.csdn.net/pcyph/article/details/45010609

### VSCode快速处理所有冲突
https://www.jianshu.com/p/cf5c67901ae0

### VS Code查看C++汇编
https://blog.csdn.net/u011018840/article/details/120900295
clion直接用gdb的disas

### C++ getline函数用法详解
https://www.cnblogs.com/wkfvawl/p/11040760.html
https://blog.csdn.net/u011630575/article/details/79721024
https://blog.csdn.net/six66667/article/details/80659035

### C++ 使用 stringstream与getline()分割字符串
https://blog.csdn.net/qq_36743440/article/details/91999615
https://blog.csdn.net/sunshineacm/article/details/78068987


### C++字符串和数字转换完全攻略
http://c.biancheng.net/view/1527.html

### c++使用库函数判断字符是否是数字
https://blog.csdn.net/liuweiyuxiang/article/details/50850104
https://www.cnblogs.com/r1-12king/p/13161762.html

### C++ STL算法系列3---求和：accumulate
https://www.cnblogs.com/heyonggang/p/3241878.html

https://blog.csdn.net/fengbingchun/article/details/77949873?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EHighlightScore-2.queryctrv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EHighlightScore-2.queryctrv2&utm_relevant_index=3

https://blog.csdn.net/qq_37653144/article/details/80135046

标准库头文件 <functional>:https://www.apiref.com/cpp-zh/cpp/header/functional.html
函数对象：http://cppds.com/cpp/utility/functional.html
Cpp-learning-notes：https://roachsinai.github.io/Cpp-learning-notes/

### vim全局替换命令
https://blog.51cto.com/andyss/131652



[toc]

# C++ 知识点总结

### 1.类成员函数放在类声明中实现，则此函数默认是内联函数





### 2.条件同时满足的写法

```C++
// a, b, c 同时为1时返回true；否则返回false
// 写法1
if (a && b && c) {
	return true;
}

// 写法2
if (!a) {
	return false;
}
if (!b) {
	return false;
}
if (!c) {
	return false;
}
return true;
```

这种好处是针对很长的条件判断，易读性较好。



### 3.回调函数(callback)

**一般来说**，只要参数是一个函数，那么这个函数就是回调。

很多初学者不明白 callback 的用法，因为 callback 有一点「反直觉」。

比如说我们用代码做一件事情，分为两步：step1( ) 和 step2( )。

符合人类直觉的代码是：

```
step1()
step2()
```

callback 的写法却是这样的：

```
step1(step2)
```

为什么要这样写？或者说在什么情况下应该用这个「反直觉」的写法？

一般（注意我说了一般），在 step1() 是一个异步任务的时候，就会使用 callback。



### 4.位域的使用

有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为"位域"或"位段"。

所谓"位域"是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。

**典型的实例：**

- 用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。
- 读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。



**位域定义：** 

位域定义与结构定义相仿，可采用先定义后说明，同时定义说明或者直接说明这三种方式。其形式为：

```
struct 位域结构名 
{
 位域列表
};

其中位域列表的形式为：
type [member_name] : width ;

struct packed_struct {
    unsigned int f1:1;
    unsigned int f2:1;
    unsigned int f3:1;
    unsigned int f4:1;
    unsigned int type:4;
    unsigned int my_int:9;
};
可以替换为：
struct packed_struct {
    unsigned int f1:1,
                 f2:1,
                 f3:1,
                 f4:1,
                 type:4;
    unsigned int my_int:9;
};
```



**对于位域的定义尚有以下几点说明：**

- 一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：

  ```C++
  struct bs{
      unsigned a:4;
      unsigned  :4;    /* 空域 */
      unsigned b:4;    /* 从下一单元开始存放 */
      unsigned c:4;
  }; // 在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。
  ```

- 位域的宽度不能超过**它所依附的**数据类型的长度，成员变量都是有类型的，这个类型限制了成员变量的最大长度，**:** 后面的数字不能超过这个长度。

- 位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：

  ```C++
  struct k{
      int a:1;
      int  :2;    /* 该 2 位不能使用 */
      int b:3;
      int c:2;
  };
  ```

从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。



**位域的使用：**

位域的使用和结构成员的使用相同，其一般形式为：

```
位域变量名.位域名
位域变量名指针->位域名
```

位域允许用各种格式输出。

```C++
int main(){
    struct bs{
        unsigned a:1;
        unsigned b:3;
        unsigned c:4;
    } bit,*pbit;
    bit.a=1;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    bit.b=7;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    bit.c=15;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    printf("%d,%d,%d\n",bit.a,bit.b,bit.c);    /* 以整型量格式输出三个域的内容 */
    pbit=&bit;    /* 把位域变量 bit 的地址送给指针变量 pbit */
    pbit->a=0;    /* 用指针方式给位域 a 重新赋值，赋为 0 */
    pbit->b&=3;    /* 使用了复合的位运算符 "&="，相当于：pbit->b=pbit->b&3，位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&011=011，十进制值为 3） */
    pbit->c|=1;    /* 使用了复合位运算符"|="，相当于：pbit->c=pbit->c|1，其结果为 15 */
    printf("%d,%d,%d\n",pbit->a,pbit->b,pbit->c);    /* 用指针方式输出了这三个域的值 */
}
```

位域结构体中的变量不能取地址。

有符号数在机器中是以**补码**的形式存在的，其正负的判断有其规则。位域是以**原码**的形式来进行操作的，这中间有差异。而关于位域的正负数判断，也不是简单的首bit的0或1来决定，否则上面的结果就应该是-1 -2 -3或者1 2 3了。位域的实现，是编译器相关的。**建议是，使用位域不要使用正负这样的特性**——理论上来说，应该只关注定义的那几个bit的0或者1，是无符号的。可以使用无符号类型来定义位域，这样不会产生正负号这样的问题。



**存储说明：** 

类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。

位域在内存中的布局是与机器有关的

位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定

取地址运算符（&）不能作用于位域，任何指针都无法指向类的位域



无论小端还是大端，先定义的位域占据低bit地址。

我们常用的x86结构是小端模式，而KEIL C51则为大端模式。 很多的ARM，DSP都为小端模式。 有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。



**非const引用不应绑定到位域字段，**

由于指针不能指向位字段,因此非const引用不能绑定到位字段.

非常量引用不能绑定(bind)到位域，原因与指针不能指向位域的原因相同。

虽然没有指定引用是否占用存储空间，但很明显，在非平凡的情况下，它们被实现为伪装的指针，并且引用的这种实现是语言作者“有意”的。就像指针一样，引用必须指向一个可寻址的存储单元。不可能将非常量引用绑定(bind)到不可寻址的存储单元。由于非常量引用需要直接绑定(bind)，因此非常量引用不能绑定(bind)到位域。

产生可以指向位域的指针/引用的唯一方法是实现某种“ super 指针”，除了存储中的实际地址外，还包含某种位偏移量和位宽信息，以便告诉编写代码要修改哪些位。请注意，此附加信息必须存在于所有数据指针类型中，因为 C++ 中没有“位域指针/引用”这样的类型。这基本上等同于实现更高级别的存储寻址模型，与底层操作系统/硬件平台提供的寻址模型完全分离。出于纯粹的效率考虑，C++ 语言从未打算要求对底层平台进行这种抽象。

一种可行的方法是引入一个单独的指针/引用类别，例如“位域的指针/引用”，它具有比普通数据指针/引用更复杂的内部结构。这样的类型可以从普通的数据指针/引用类型转换，但反过来不行。但这似乎并不值得。

在实际情况下，当我必须处理打包成位和位序列的数据时，我通常更喜欢手动实现位域并避免语言级别的位域。位域的名称是一个编译时实体，不可能进行任何类型的运行时选择。当需要运行时选择时，更好的方法是声明一个普通的 `uint32_t`数据字段并手动管理其中的单个位和位组。这种手动“位域”的运行时选择很容易通过掩码和移位(两者都可以是运行时值)实现。基本上，这接近于上述“ super 指针”的手动实现。



> 参考资料
>
> C 位域：https://www.runoob.com/cprogramming/c-bit-fields.html
>
> 



### 5.protected访问权限

> Java 包(package)
>
> 为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。
>
> 包的作用
>
> - 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
> - 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。
> - 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。
>
> Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。



当父类与子类位于同一包中时，不管是子类对象还是父类对象都可以访问protected，但是它们的意义是不一样的；对于子类对象，之所以可以访问是因为：子类从父类继承了protected成员，理所当然可以访问；父类对象（在子类中创建的）之所以可以访问是因为protected提供了包访问极限！


  当父类与子类位于不同包中时，protected成员就只能通过子类对象来访问（因为protected对于子类是可见的），而父类对象不再可以访问！不过，可以访问static 成员（因为protected的包访问极限已失去作用）



### 6.inline函数

内联函数：告知编译器在进行有内联标识的函数调用时将函数体部分在调用处展开。这样做可以消除函数传参（堆栈调用）的负担，提高了函数的调用效率。

而且inlining的函数并不存在，因为已经被展开了。


如果需要定义一个内联函数，需要在函数体定义的地方使用inline关键字标识，写在函数声明处是没有意义的。原因是一个函数要inline，编译器必须见过它的实现，否则编译器无米之炊无法inline。

```C++
int func(int);  //函数声明
 
inline int func(int a)  //函数定义
{ 
    return ++a;
}
```

1. 在C++类的实现过程中，如果想要将成员函数设置成inline内联函数的话，需要在类的头文件.h中定义这个函数，不能在相应的.cpp文件中定义。

2. 在类内部定义的成员函数默认设置成内联函数。

3. inline内联关键字只是给编译器一个建议，有些函数即使有inline标识，也不会被设置成内联函数。

4. 有些函数即使没有inline标识，编译器在优化时也有可能将这个函数作为内联函数来处理。





# git

### git SSH 秘钥生成

秘钥路径：

```	bash
cd ~/.ssh
================>>
authorized_keys2  id_dsa       known_hosts
config            id_dsa.pub
```

在 git bash 中输入命令，引号中内容为邮箱：

```bash
ssh-keygen -t rsa -C "cuichaoran@huawei.com"
```

该命令会在用户主目录（Windows：C:\Users\用户名\，Linux：~/）里生产.ssh文件夹，里面有id_rsa和id_rsa.pub两个文件，这两个文件就是SSH Key的秘钥对。其中，id_rsa是私钥，不能泄露，id_rsa.pub是公钥，可以告诉别人。

拷贝 SSH 秘钥后要修改权限：

```bash 
一般拷贝后文件权限会改变，
chmod 700 id_rsa id_rsa.pub
# 或者
chmod 600 id_rsa id_rsa.pub
```

原因是秘钥权限不能对其他用户开放，否则秘钥就会被忽略，用 SSH 访问时报如下警告，

```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Permissions 0777 for 'liydsshkey' are too open.
It is required that your private key files are NOT accessible by others.
This private key will be ignored.
```

Windows下秘钥默认权限：-rw-r--r--

> 参考资料
>
> [服务器上的 Git - 生成 SSH 公钥](https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5)
>
> 

### 1.git 添加多个远程仓库

* 查看已关联的远程仓库

  ```bash
  git remote -v
  ```

* 添加一个远程仓库（输入的时候不需要输入 `<` 和 `>`）

  ```bash
  git remote add <name> <url>
  ```

  其中，`name` 表示你要给这个远程库起的名字，`url` 表示这个库的地址

* 取消本地目录下关联的远程库

  ```bash
  git remote remove <name>
  ```

  其中，`name` 表示你要给这个远程库起的名字

  





------

补充：
推送到远程库上面已经说了。删除远程分支比较麻烦。一种方式是，可以直接在 github 网页上操作，另一种方式是：`git push <name> :<branch>` （注意冒号前的空格）



### 2.git cherry-pick



如果要中断这次cherry-pick,则使用git cherry-pick --quit，这种情况下当前分支中未冲突的内容状态将为modified，

如果要取消这次cherry-pick,则使用git cherry-pick --abort，这种情况下当前分支恢复到cherry-pick前的状态，没有改变。





 推代码到远程仓库

```
$ git pull <仓库关联命名> <远程分支名>:<本地分支名>
```

从远程分支拉取代码

```
$ git push <仓库关联命名> <本地分支名>:<远程分支名>
```





### 3.git 在指定的commit id点创建分支

显示 commit id 而不是分支名的情况：

1. 在本地 A 仓库拉取 B 仓库 master 分支，checkout 到 B/master后，是只有最新 commit id 而没有分支名称的，因此为了后续推代码要新建分支名称。

2. cherry-pick后的代码没有分支名，只有最新的commit id，同样需要为最新的commit id创建一个分支，用于推送远程仓库时。



若当前仓库显示的是 commit id 而不是分支名称，可以使用以下方法新建分支：

* 方法1：

  ```bash
  git checkout -b <new_branch_name> <commid_id>
  ```

  其中，`new_branch_name` 是要创建的新的本地分支名称，`commid_id` 是cherry-pick后的最新commit id。

* 方法2：

  ```bash
  git switch -c <new_branch_name>
  ```

  

### 4.git pull操作

在克隆远程项目的时候，本地分支会自动与远程仓库建立追踪关系，可以使用默认的origin来替代远程仓库名，因此下文中的 <仓库关联命名> 常常写成 origin。若一个本地仓库关联了多个远程仓库，则需要根据实际情况选择 <仓库关联命名>。

* 将远程指定分支拉取到本地**指定**分支上：

  ```bash
  git pull <仓库关联命名> <远程分支名>:<本地分支名>
  ```


* 将远程指定分支拉取到本地**当前**分支上：

  ```bash
  git pull <仓库关联命名> <远程分支名>
  ```

* 将与本地当前分支**同名**的远程分支拉取到本地**当前**分支上(需先关联远程分支，方法如下)

  ```bash
  git pull
  
  // 将本地分支与远程同名分支相关联
  git push --set-upstream origin <本地分支名>
  // 简写方式：
  git push -u origin <本地分支名>
  ```

  在克隆远程项目的时候，本地分支会自动与远程仓库建立追踪关系，可以使用默认的origin来替代远程仓库名，
  所以，我常用的命令就是 git pull origin <远程仓库名>，操作简单，安全可控。

* 将远程指定分支拉取到本地**指定**分支上（本地不存在的分支）:

  ```bash
  git fetch
  git checkout -b 本地分支名 origin/远程分支名
  ```

* 远端分支强制覆盖本地分支

  ```bash
  git fetch origin <远程分支名>
  git reset --hard origin/<远程分支名>
  #  或者使用下面的命令
  git fetch --all
  git reset --hard origin/<远程分支名>
  ```
  
  

### 5.git push操作

* 将本地当前分支推送到远程**指定**分支上：

  ```bash
  git push <仓库关联命名> <本地分支名>:<远程分支名>
  ```

* 将本地当前分支推送到与本地当前分支**同名**的远程分支上（如果远程仓库没有这个分支，则会新建一个该分支）：

  ```bash
  git push <仓库关联命名> <本地分支名>
  ```

* 将本地当前分支推送到与本地当前分支**同名**的远程分支上(需先关联远程分支，方法方法如下)

  ```bash
  git push
  
  // 将本地分支与远程同名分支相关联
  git push --set-upstream origin <本地分支名>
  // 简写方式：
  git push -u origin <本地分支名>
  ```

  同样的，推荐使用第2种方式，git push origin <远程同名分支名>

> 注意：pull是远程在前本地在后，push相反



### 6.git clone

git clone 只能 clone 远程库的 master 分支，无法 clone 所有分支。



### 7.git rebase

rebase的作用简要概括为：可以对某一段线性提交历史进行编辑、删除、复制、粘贴；因此，合理使用rebase命令可以使我们的提交历史干净、简洁！

**使用git rebase合并多次commit：**

* 方法1：指名要合并的版本号区间

    ```bash
    git rebase -i  [startpoint]  [endpoint]
    ```

    其中 `-i` 的意思是 `--interactive`，即弹出交互式的界面让用户编辑完成合并操作，`[startpoint] [endpoint]`则指定了一个编辑区间，如果不指定`[endpoint]`，则该区间的终点默认是当前分支 HEAD 所指向的 commit （注：该区间指定的是一个前开后闭的区间，`[startpoint]` **本身不参与合并**，可以把它当做一个坐标）。

* 方法2：从HEAD版本开始往过去数3个版本

  ```bash
  git rebase -i HEAD~3 
  ```

  

  在弹出的 vim 编辑窗口中，会列出要合并的 commit message，提交时间最早的列在上面，最晚的在下面，由于 squash 是要和前一个 commit 合并，因此**最早的一个填 pick，比较晚的几个都填 squash**，然后 `:wq` 即可。

  > 指令解释（交互编辑时使用）：
  >
  > pick：保留该commit（缩写:p）
  >
  > reword：保留该commit，但我需要修改该commit的注释（缩写:r）
  >
  > edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）
  >
  > squash：将该commit和前一个commit合并（缩写:s）
  >
  > fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）
  >
  > exec：执行shell命令（缩写:x）
  >
  > drop：我要丢弃该commit（缩写:d）





### 8.git commit

> --amend 通过创建一个新的 commit 来替换当前分支的尖端。

修改 commit message，「amend：修改、修正」

```bash
git commit --amend
```

在弹出的 vim 编辑窗口中，最上方，修改 message 后，:wq 即可。

> 

> 参考网址
>
> [7.6 Git 工具 - 重写历史](https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2)

### 9.git reset

git reset 命令用于回退版本，可以指定退回某一次提交的版本。

```
git reset [--soft | --mixed | --hard] [HEAD]
```

**--mixed** 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。



```bash
HEAD 说明：
HEAD 表示当前版本
HEAD^ 上一个版本
HEAD^^ 上上一个版本
HEAD^^^ 上上上一个版本
以此类推...

可以使用 ~ 数字表示
HEAD~0 表示当前版本
HEAD~1 上一个版本
HEAD^2 上上一个版本
HEAD^3 上上上一个版本
以此类推...
```



### 10.git branch

* 本地分支重命名（还没有推送到远程）

  如果对于分支不是当前分支，可以使用下面代码：

  ```bash
  git branch -m <原分支名> <新分支名>
  ```

  如果是当前分支，那么可以使用加上新名字：

  ```bash
  git branch -m <新分支名>
  ```

* 远程分支重命名（已经推送远程-假设本地分支和远程对应分支名称相同，且处于本地分支）

  a. 重命名远程分支对应的本地分支

  ```shell
  git branch -m <原分支名> <新分支名>
  ```

  b. 删除远程分支

  ```shell
  git push --delete origin <原分支名>
  ```

  c. 上传新命名的本地分支

  ```shell
  git push origin <新分支名>
  ```

  d.把修改后的本地分支与远程分支关联

  ```shell
  git branch --set-upstream-to origin/<新分支名>
  ```

  







# Vscode

### 查看反汇编代码

运行程序后，在监视变量中添加：

```bash
-exec disassemble /m main
# 或
-exec disassemble /m
```

然后在**<font color=red>调试控制台</font>**就可以看到汇编代码了。


















