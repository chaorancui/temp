[toc]

# 计算机基础

## IEEE754 标准: 一 , 浮点数在内存中的存储方式

> <https://zhuanlan.zhihu.com/p/343033661>

### 存储方式

| 浮点类型 | 内存占用（位） | 内存分配                           | 指数范围     | 指数偏移 | 范围（约等于）                                                                                  | 精度                                           |
| -------- | -------------- | ---------------------------------- | ------------ | -------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------------- |
| float    | 32             | 1 符号位<br>8 指数位<br>23 尾数位  | [-127, 128]  | +127     | $ [-3.4*10^{38}, -1.18*10^{-38}] $ <br> $ \bigcup $ <br> $ [1.18*10^{-38}, 3.4*10^{38}] $       | 7~8 位有效数字<br>（7 位肯定保证，8 位也存在） |
| double   | 64             | 1 符号位<br>11 指数位<br>52 尾数位 | [-1023, 1024 | +1023    | $ [-1.80*10^{308}, -2.23*10^{-308}] $ <br> $ \bigcup $ <br> $ [2.23*10^{-308}, 1.80*10^{308}] $ | 16-17 位有效数字                               |

下面主要研究 32 位浮点数 (或者说单精度浮点数, 或者说 float 类型) 在计算机中是怎么存储的. 其他精度, 比如 64 位浮点数, 则大同小异.
以一个 32 位浮点数 `20.5` 为例，其占用的 32 个二进制位的内存编号从高到低 (从 31 到 0), 共包含如下几个部分:

| 1bit（符号位） | 8bits（指数位） |       23bits（尾数位）       |
| :------------: | :-------------: | :--------------------------: |
|       1        |    1000 0011    | 0100 1000 0000 0000 0000 000 |

- **sign**: 符号位。
- **biased exponent**: 偏移后的指数位。
- **fraction**: 尾数位。

下面会依次介绍这三个部分的概念, 用途.

1. **符号位: sign**

   符号位: 占据最高位(第 31 位)这一位, 用于表示这个浮点数是正数还是负数, **为 0 表示正数, 为 1 表示负数**。

   举例: 对于十进制数 `20.5`, 存储在内存中时, 符号位应为**0**, 因为这是个**正数**。
   &nbsp;

2. **偏移后的指数位: biased exponent**

   用于表示以 2 位底的指数。用这个指数对尾数进行缩放。对 32 位浮点型其 8 位指数位的二进制可以表示 **256 种状态**, **IEEE754 规定, 指数位用于表示[-127, 128]范围内的指数**。

   指数位部分还要表示表示负数，会让内存解析更加复杂，因此给指数位添加一个**固定的偏移量**，以使指数位中始终都是一个**非负整数**。

   **规定: 在 32 位单精度类型中, 这个偏移量是 127。在 64 位双精度类型中, 偏移量是 1023。**

   举例: 如果你运算后得到的指数是 -10, 那么偏移后, 在指数位中需要表示为: -10 + 127(偏移量) = **117**
   &nbsp;

3. **尾数位:fraction**

   在以二进制格式存储十进制浮点数时, 首先需要把十进制浮点数表示为二进制格式, 还拿十进制数 `20.5` 举例:

   十进制浮点数 `20.5` = 二进制 `10100.1`，然后需要把这个二进制数转换为以 2 为底的指数形式:

   二进制 `10100.1 = 1.01001 * 2^4`

   注意转换时, 对于乘号左边的二进制数**1.01001**, 需要把小数点放在左起第一位和第二位之间，且第一位需要是个非 0 数。这样表示好之后, 其中的**1.01001**就是**尾数。**

   > 用 二进制数 表示 十进制浮点数 时, 表示为 `尾数 * 指数` 的形式, 并把尾数的小数点放在第一位和第二位之间, 然后保证第一位数非 0, 这个处理过程叫做**规范化(normalized)**。

   其中 1.01001 是**尾数**, 而 4 就是**偏移前的指数(unbiased exponent)**, 上文讲过, 32 位单精度浮点数的偏移量(bias)为 127, 所以**偏移后指数(biased exponent)**就是 **4 + 127 = 131**, 131 转换为二进制就是**1000 0011**

   现在还需要对**尾数**做一些特殊处理

   - **隐藏高位 1.**

     你会发现, 尾数部分的最高位始终为**1.** 比如这里的 **1.**01001，这是因为前面说过，规范化之后，尾数中的小数点会位于左起第一位和第二位之间，且第一位是个非 0 数。
     而二进制中, 每一位可取值只有 0 或 1, 如果第一位非 0, 则第一位只能为 1. 所以在存储尾数时, 可以省略前面的 **1.**，只记录尾数中小数点之后的部分, 这样就节约了一位内存. 所以这里只需记录剩余的尾数部分: **01001**

     所以, 以后再提到尾数, 如无特殊说明, 指的其实是隐藏了整数部分**1.** 之后, 剩下的小数部分

   - **低位补 0**

     有时候尾数会不够填满尾数位。比如尾数 01001 不够 23 位，此时需要在**低位补零**, 补齐 23 位。

     之所以在低位补 0, 是因为尾数中存储的本质上是二进制的小数部分, 所以如果想要在不影响原数值的情况下, 填满 23 位, 就需要在低位补零。

     原尾数是: `01001`(不到 23 位)

     补零之后是: `0100 1000 0000 0000 0000 000` (补至 23 位)

### 精度说明

浮点数的精确度是按照**整体有效位数来的，并不是只是考虑小数部分**。

**float 的精度为 7~8 位有效数字**（7 位肯定能保证，8 位的值也存在），而不是 7 位小数。

**double 的精度为 16~17 位有效数字**。

看一段代码

```java
public class Main {

    public static void main(String[] args) {
        float f6 = 1.000003f;//6位小数位,总共7位
        float f7 = 1.0000003f;//7位小数位，总共8位
        float f8 = 1.00000003f;//8位小数位，总共9位
        float f_8 = 10.000003f;//6位小数位,总共8位
        float f_9 = 10.0000003f;//7位小数位,总共9位
        float f_10 = 10.00000003f;//8位小数位,总共10位

        double d15 = 1.000000000000003;//15位小数位，总共16位
        double d16 = 1.0000000000000003;//16位小数位，总共17位
        double d17 = 1.00000000000000003;//17位小数位，总共18位
        double d_17 = 10.000000000000003;//15位小数位，总共17位
        double d_18 = 10.0000000000000003;//16位小数位，总共18位
        double d_19 = 10.00000000000000003;//17位小数位，总共19位

        System.out.println("结果为false证明 == 校验到了小数点位, 精确度可信");
        System.out.println("float(7位有效,6位小数)    1.000003f  == 1           的结果是：" + (f6==1));
        System.out.println("float(8位有效,7位小数)    1.0000003f == 1           的结果是：" + (f7==1));
        System.out.println("float(9位有效,8位小数)    1.00000003f  == 1         的结果是：" + (f8==1));
        System.out.println("float(8位有效,6位小数)    10.000003f  == 10         的结果是：" + (f_8==10));
        System.out.println("float(9位有效,7位小数)    10.0000003f  == 10        的结果是：" + (f_9==10));
        System.out.println("float(10位有效,8位小数)   10.00000003f  == 10       的结果是：" + (f_10==10));
        System.out.println("------------------");

        System.out.println("double(16位有效,15位小数) 1.000000000000003 == 1    的结果是：" + (d15==1));
        System.out.println("double(17位有效,16位小数) 1.0000000000000003 == 1   的结果是：" + (d16==1));
        System.out.println("double(18位有效,17位小数) 1.00000000000000003 == 1  的结果是：" + (d17==1));
        System.out.println("double(17位有效,15位小数) 10.000000000000003 == 10  的结果是：" + (d_17==10));
        System.out.println("double(18位有效,16位小数) 10.0000000000000003 == 10 的结果是：" + (d_18==10));
        System.out.println("double(19位有效,17位小数) 10.00000000000000003 == 10的结果是：" + (d_19==10));
    }
}
```

![img](https://i-blog.csdnimg.cn/blog_migrate/356fc47b10a75ce1b7582e74f3118135.png)

结果为 false 的，那么小数点存在有意义，也就是精确位。从结果来看，float 可以精确到有效数字 8 位， double 到了 17 位。

> 上文为简单直接使用 `==` 比较浮点数大小，实际请不要采用这种方法。
> 不可将浮点变量用 `==` 或 `！=` 与任何数字比较。因为有些浮点数是近似存储的，且计算机会把精度之外的小数部分截断，导致判断结果不可靠。
> 解决方案：定义一个精度，用差的绝对值比较，差值在精度范围内就认为是相等的。

## 大模型中常用浮点数

彻底搞懂 float16 与 float32 的计算方式：<https://blog.csdn.net/leo0308/article/details/117398166>

**大模型精度（FP16，FP32，BF16）详解与实践**:<https://www.53ai.com/news/qianyanjishu/2024052494875.html>

FP16 与 BF16 区别:<https://transformerswsz.github.io/2024/05/05/FP16%E4%B8%8EBF16%E5%8C%BA%E5%88%AB/>

## 整数的位操作：按位与&、或|、异或^、取反~

**机器数：**一个数在计算机中的二进制表示形式, 叫做这个数的机器数。**机器数是带符号的**，在计算机用一个数的最高位存放符号, 正数为 0, 负数为 1。比如，十进制中的数 +3 ，计算机字长为 8 位，转换成二进制就是 00000011。如果是 -3 ，就是 10000011 。这里的 00000011 和 10000011 就是机器数。

**真值：**因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位 1 代表负，其真正数值是 -3 而不是形式值 131（10000011 转换成十进制等于 131）。所以，为区别起见，将**带符号位的机器数对应的真正数值称为机器数的真值**。例：0000 0001 的真值 = +000 0001 = +1，1000 0001 的真值 = –000 0001 = –1

正数：原码 = 反码 = 补码

负数：原码、反码为原码除符号为按位取反、补码为反码加 1

整数在计算机中是**以补码的方式存储**。

这些操作都是按**补码**来操作的，输出为 8 进制或 16 进制时也是输出的补码，输出为 10 进制时才转换为机器数真值。

```C++
// -88&100 负数参与按位且，分析步骤
     1111 1111 1010 1000 // -88补码
    &0000 0000 0110 0100 // 100补码
     -------------------
     0000 0000 0010 0000 // 转成十进制结果为：32， 即-88&100 = 32
```

## MAC 地址

> 参考：
>
> 1. [Mac 地址是什么意思？](https://www.amazonaws.cn/knowledge/what-is-media-access-control-address/)

### Mac 地址和 ip 地址的区别

Mac 地址（Media Access Control Address）和 IP 地址（Internet Protocol Address）都是用于标识网络设备的唯一地址，但它们在许多方面存在显著差异：

**唯一性和可变性：**

- Mac 地址是网络设备在制造时被分配的唯一硬件地址，通常是永久不变的。修改 Mac 地址相对困难，需要特殊工具和权限。
- IP 地址是软件分配的逻辑地址，可以根据网络拓扑结构和配置进行动态修改和重新分配。

**地址分配：**

- Mac 地址由网络设备制造商统一分配，确保全球唯一性。
- IP 地址由网络管理员或 DHCP 服务器根据网络拓扑结构动态分配。

**寻址协议层：**

- Mac 地址工作在 OSI 参考模型的数据链路层（第二层），用于在局域网内传输数据帧。
- IP 地址工作在网络层（第三层），用于在不同网络之间传输数据包。

**地址长度：**

- Mac 地址长度为 48 位（6 个字节），通常以十六进制表示，如 00-14-22-01-23-45。
- IP 地址长度为 32 位（4 个字节），通常以十进制点分格式表示，如 192.168.0.1。

**作用范围：**

- Mac 地址由网络设备制造商统一分配，确保全球唯一性。
- IP 地址由网络管理员或 DHCP 服务器根据网络拓扑结构动态分配。

**关联性：**

- 一个网络设备可以有多个 IP 地址，但只有一个 Mac 地址。
- IP 地址和 Mac 地址之间存在动态映射关系，通过 ARP 协议实现。

总之，Mac 地址和 IP 地址虽然都具有唯一性，但在地址长度、分配方式、作用层次和范围等方面存在明显差异，分别用于不同层次的网络通信。

### Mac 地址的组成部分

**MAC 地址的表示形式：**

MAC 地址通常由 6 组两位十六进制数字组成，组与组之间用连字符、冒号或无分隔符分隔。它们主要由设备制造商分配，通常被称为烧录地址、以太网硬件地址、硬件地址或物理地址。每个 MAC 地址可以存储在接口硬件的只读存储器中，或由固件机制存储。

**MAC 地址的编号空间：**

MAC 地址是根据 IEEE（电气和电子工程师协会）管理的两个基于扩展唯一标识符（EUI）的编号空间的原则形成的：EUI-48（取代了已废弃的 MAC-48 术语）和 EUI-64。最初的 IEEE 802 MAC 地址源自 Xerox 网络系统的以太网寻址方案，包含超过 281 万亿种可能的 MAC 地址。

**MAC 地址的唯一性：**

具有多个网络接口的网络节点（如路由器和多层交换机）必须为同一网络中的每个网络接口分配一个唯一的 MAC 地址。但是，连接到两个不同网络的两个网络接口可以共享同一个 MAC 地址。

### Mac 地址的分配规则

Mac 地址是一种唯一的标识符，用于识别网络设备。它们由设备制造商分配，通常被称为 "烧录地址" 或 "以太网硬件地址"。Mac 地址的分配遵循 IEEE 管理的两种编号空间的原则：EUI-48（取代了过时的 MAC-48）和 EUI-64。IEEE 负责管理 Mac 地址的分配，为使用 EUI-48 空间的应用程序设置了 100 年的目标使用期限（直至 2080 年）。IEEE 还鼓励采用更加丰富的 EUI-64 用于非以太网应用。IEEE 还提供了其他 Mac 地址分配机制，如 MA-S 注册表（包括一批 EUI-48 和 EUI-64 标识符）和 MA-M（提供 220 个 EUI-48 和 236 个 EUI-64 标识符）。具有多个接口（如路由器和交换机）的网络节点必须为同一网络中的每个接口分配一个唯一的 Mac 地址。但是，连接到不同网络的两个接口可以共享同一 Mac 地址。

MAC 地址是一个 **48 位（6 字节）** 的二进制数，通常表示为 **12 位十六进制数**，格式如下：

```bash
XX:XX:XX:XX:XX:XX
# 或
XX-XX-XX-XX-XX-XX
```

其中，每个 `X` 代表一个十六进制数（0-9，A-F）。

- **前 24 位（3 字节）**：组织唯一标识符（OUI，Organizationally Unique Identifier）

  - 由 IEEE（国际电气电子工程师学会）分配给设备制造商
  - 例如，`00:1A:2B` 可能代表某个厂商

- **后 24 位（3 字节）**：设备标识（Device Identifier）

  - 由厂商自行分配，确保同一厂商生产的设备不会冲突

示例：

```bash
00:1A:2B:3C:4D:5E
```

- `00:1A:2B` → 设备制造商的标识（OUI）
- `3C:4D:5E` → 设备的唯一编号

### Mac 地址的作用

Mac 地址的主要作用是唯一标识网络接口控制器（NIC）以用作网络段内通信的网络地址。Mac 地址由设备制造商分配，在 OSI 网络模型中的数据链路层的媒体访问控制子层中使用。Mac 地址可识别为由连字符、冒号或无分隔符分隔的六组两个十六进制数字，允许在广播网络（如以太网）上为特定主机标记帧，构成链路层网络的基础。Mac 地址确保了数据包能够正确地路由到目的地，是网络基础设施的重要组成部分。

- 用于以太网和 Wi-Fi 设备间的数据传输。
- 通过 ARP（地址解析协议） 解析 IP 地址到 MAC 地址，实现网络通信。
- 作为网络安全机制的一部分，可用于 MAC 地址过滤、防止未授权设备接入。
