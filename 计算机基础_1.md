[toc]

## IEEE754 标准: 浮点数存储

> <https://zhuanlan.zhihu.com/p/343033661>

### 存储方式

| 浮点类型 | 内存占用（位） | 内存分配                           | 指数范围     | 指数偏移 | 范围（约等于）                                                                                  | 精度                                           |
| -------- | -------------- | ---------------------------------- | ------------ | -------- | ----------------------------------------------------------------------------------------------- | ---------------------------------------------- |
| float    | 32             | 1 符号位<br>8 指数位<br>23 尾数位  | [-127, 128]  | +127     | $ [-3.4*10^{38}, -1.18*10^{-38}] $ <br> $ \bigcup $ <br> $ [1.18*10^{-38}, 3.4*10^{38}] $       | 7~8 位有效数字<br>（7 位肯定保证，8 位也存在） |
| double   | 64             | 1 符号位<br>11 指数位<br>52 尾数位 | [-1023, 1024 | +1023    | $ [-1.80*10^{308}, -2.23*10^{-308}] $ <br> $ \bigcup $ <br> $ [2.23*10^{-308}, 1.80*10^{308}] $ | 16-17 位有效数字                               |

下面主要研究 32 位浮点数 (或者说单精度浮点数, 或者说 float 类型) 在计算机中是怎么存储的. 其他精度, 比如 64 位浮点数, 则大同小异.
以一个 32 位浮点数 `20.5` 为例，其占用的 32 个二进制位的内存编号从高到低 (从 31 到 0), 共包含如下几个部分:

| 1bit（符号位） | 8bits（指数位） |       23bits（尾数位）       |
| :------------: | :-------------: | :--------------------------: |
|       1        |    1000 0011    | 0100 1000 0000 0000 0000 000 |

- **sign**: 符号位。
- **biased exponent**: 偏移后的指数位。
- **fraction**: 尾数位。

下面会依次介绍这三个部分的概念, 用途.

1. **符号位: sign**

   符号位: 占据最高位(第 31 位)这一位, 用于表示这个浮点数是正数还是负数, **为 0 表示正数, 为 1 表示负数**。

   举例: 对于十进制数 `20.5`, 存储在内存中时, 符号位应为**0**, 因为这是个**正数**。
   &nbsp;

2. **偏移后的指数位: biased exponent**

   用于表示以 2 位底的指数。用这个指数对尾数进行缩放。对 32 位浮点型其 8 位指数位的二进制可以表示 **256 种状态**, **IEEE754 规定, 指数位用于表示[-127, 128]范围内的指数**。

   指数位部分还要表示表示负数，会让内存解析更加复杂，因此给指数位添加一个**固定的偏移量**，以使指数位中始终都是一个**非负整数**。

   **规定: 在 32 位单精度类型中, 这个偏移量是 127。在 64 位双精度类型中, 偏移量是 1023。**

   举例: 如果你运算后得到的指数是 -10, 那么偏移后, 在指数位中需要表示为: -10 + 127(偏移量) = **117**
   &nbsp;

3. **尾数位:fraction**

   在以二进制格式存储十进制浮点数时, 首先需要把十进制浮点数表示为二进制格式, 还拿十进制数 `20.5` 举例:

   十进制浮点数 `20.5` = 二进制 `10100.1`，然后需要把这个二进制数转换为以 2 为底的指数形式:

   二进制 `10100.1 = 1.01001 * 2^4`

   注意转换时, 对于乘号左边的二进制数**1.01001**, 需要把小数点放在左起第一位和第二位之间，且第一位需要是个非 0 数。这样表示好之后, 其中的**1.01001**就是**尾数。**

   > 用 二进制数 表示 十进制浮点数 时, 表示为 `尾数 * 指数` 的形式, 并把尾数的小数点放在第一位和第二位之间, 然后保证第一位数非 0, 这个处理过程叫做**规范化(normalized)**。

   其中 1.01001 是**尾数**, 而 4 就是**偏移前的指数(unbiased exponent)**, 上文讲过, 32 位单精度浮点数的偏移量(bias)为 127, 所以**偏移后指数(biased exponent)**就是 **4 + 127 = 131**, 131 转换为二进制就是**1000 0011**

   现在还需要对**尾数**做一些特殊处理

   - **隐藏高位 1.**

     你会发现, 尾数部分的最高位始终为**1.** 比如这里的 **1.**01001，这是因为前面说过，规范化之后，尾数中的小数点会位于左起第一位和第二位之间，且第一位是个非 0 数。
     而二进制中, 每一位可取值只有 0 或 1, 如果第一位非 0, 则第一位只能为 1. 所以在存储尾数时, 可以省略前面的 **1.**，只记录尾数中小数点之后的部分, 这样就节约了一位内存. 所以这里只需记录剩余的尾数部分: **01001**

     所以, 以后再提到尾数, 如无特殊说明, 指的其实是隐藏了整数部分**1.** 之后, 剩下的小数部分

   - **低位补 0**

     有时候尾数会不够填满尾数位。比如尾数 01001 不够 23 位，此时需要在**低位补零**, 补齐 23 位。

     之所以在低位补 0, 是因为尾数中存储的本质上是二进制的小数部分, 所以如果想要在不影响原数值的情况下, 填满 23 位, 就需要在低位补零。

     原尾数是: `01001`(不到 23 位)

     补零之后是: `0100 1000 0000 0000 0000 000` (补至 23 位)

### 精度说明

浮点数的精确度是按照**整体有效位数来的，并不是只是考虑小数部分**。

**float 的精度为 7~8 位有效数字**（7 位肯定能保证，8 位的值也存在），而不是 7 位小数。

**double 的精度为 16~17 位有效数字**。

看一段代码

```java
public class Main {

    public static void main(String[] args) {
        float f6 = 1.000003f;//6位小数位,总共7位
        float f7 = 1.0000003f;//7位小数位，总共8位
        float f8 = 1.00000003f;//8位小数位，总共9位
        float f_8 = 10.000003f;//6位小数位,总共8位
        float f_9 = 10.0000003f;//7位小数位,总共9位
        float f_10 = 10.00000003f;//8位小数位,总共10位

        double d15 = 1.000000000000003;//15位小数位，总共16位
        double d16 = 1.0000000000000003;//16位小数位，总共17位
        double d17 = 1.00000000000000003;//17位小数位，总共18位
        double d_17 = 10.000000000000003;//15位小数位，总共17位
        double d_18 = 10.0000000000000003;//16位小数位，总共18位
        double d_19 = 10.00000000000000003;//17位小数位，总共19位

        System.out.println("结果为false证明 == 校验到了小数点位, 精确度可信");
        System.out.println("float(7位有效,6位小数)    1.000003f  == 1           的结果是：" + (f6==1));
        System.out.println("float(8位有效,7位小数)    1.0000003f == 1           的结果是：" + (f7==1));
        System.out.println("float(9位有效,8位小数)    1.00000003f  == 1         的结果是：" + (f8==1));
        System.out.println("float(8位有效,6位小数)    10.000003f  == 10         的结果是：" + (f_8==10));
        System.out.println("float(9位有效,7位小数)    10.0000003f  == 10        的结果是：" + (f_9==10));
        System.out.println("float(10位有效,8位小数)   10.00000003f  == 10       的结果是：" + (f_10==10));
        System.out.println("------------------");

        System.out.println("double(16位有效,15位小数) 1.000000000000003 == 1    的结果是：" + (d15==1));
        System.out.println("double(17位有效,16位小数) 1.0000000000000003 == 1   的结果是：" + (d16==1));
        System.out.println("double(18位有效,17位小数) 1.00000000000000003 == 1  的结果是：" + (d17==1));
        System.out.println("double(17位有效,15位小数) 10.000000000000003 == 10  的结果是：" + (d_17==10));
        System.out.println("double(18位有效,16位小数) 10.0000000000000003 == 10 的结果是：" + (d_18==10));
        System.out.println("double(19位有效,17位小数) 10.00000000000000003 == 10的结果是：" + (d_19==10));
    }
}
```

![img](https://i-blog.csdnimg.cn/blog_migrate/356fc47b10a75ce1b7582e74f3118135.png)

结果为 false 的，那么小数点存在有意义，也就是精确位。从结果来看，float 可以精确到有效数字 8 位， double 到了 17 位。

> 上文为简单直接使用 `==` 比较浮点数大小，实际请不要采用这种方法。
> 不可将浮点变量用 `==` 或 `！=` 与任何数字比较。因为有些浮点数是近似存储的，且计算机会把精度之外的小数部分截断，导致判断结果不可靠。
> 解决方案：定义一个精度，用差的绝对值比较，差值在精度范围内就认为是相等的。

## 大模型中常用浮点数

彻底搞懂 float16 与 float32 的计算方式：<https://blog.csdn.net/leo0308/article/details/117398166>

**大模型精度（FP16，FP32，BF16）详解与实践**:<https://www.53ai.com/news/qianyanjishu/2024052494875.html>

FP16 与 BF16 区别:<https://transformerswsz.github.io/2024/05/05/FP16%E4%B8%8EBF16%E5%8C%BA%E5%88%AB/>

[那些年，AI 芯片里的浮点(FloatPoint)格式](https://zhuanlan.zhihu.com/p/449857213)

[Understanding Data Types in AI and HPC: Int8, FP8, FP16, BF16, BF32, FP32, TF32, FP64, and Hardware Accelerators](https://itsabout.ai/understanding-data-types-in-ai-and-hpc-int8-fp8-fp16-bf16-bf32-fp32-tf32-fp64-and-hardware-accelerators/)
