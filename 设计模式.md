
# 设计原则

## SOLID 原则

SOLID 是面向对象编程和设计中的五个重要原则的缩写。这些原则旨在**使软件设计更加<font color=blue>易于理解</font>、<font color=blue>灵活</font>和<font color=blue>可维护</font>**。

> SOLID 原则可以理解为总的原则，框架上的原则，还有其他实现细节上的原则，如控制反转等。

### S - 单一职责原则 (Single Responsibility Principle, SRP)

定义：**修改一个类的原因只能有一个**。
要点：
- 每个类应该只负责一项特定的功能或任务。
- 有助于提高代码的可读性、可维护性和重用性。

示例：

```cpp
// 不符合单一职责原则的类
class Employee {
public:
    void calculatePay() { /* 计算工资 */ }
    
    void reportHours() { /* 报告工时 */ }
    
    void save() { /* 保存到数据库 */ }
};

// 符合单一职责原则的类
class Employee {
public:
    void calculatePay() { /* 计算工资 */ }
};

class TimeReporter {
public:
    reportHours() { /* 报告工时 */ }
};

class EmployeeRepository {
public:
    save() { /* 保存到数据库 */ }
};
```

### O - 开闭原则 (Open-Closed Principle, OCP)

定义：**软件（类、模块、函数等）应该对扩展开放，对修改封闭**。
要点：
- 可以通过添加新代码来扩展功能，而不是修改现有代码。
- 通常通过使用抽象类和接口来实现。

示例：

```cpp
// 不符合开放封闭原则的类
class Circle {
public:
    void draw() { /* 画圆 */ }
};

class Rectangle {
public:
    void draw() { /* 画矩形 */ }
};

class GraphicEditor {
public:
    void drawShape(const Circle& circle) {
        circle.draw();
    }
    
    void drawShape(const Rectangle& rectangle) {
        rectangle.draw();
    }
};

// 符合开放封闭原则的类
class Shape {
public:
    virtual void draw() const = 0;  // 抽象接口
    virtual ~Shape() = default;
};

class Circle : public Shape {
public:
    void draw() const override { /* 画圆 */ }
};

class Rectangle : public Shape {
public:
    void draw() const override { /* 画矩形 */ }
};

class GraphicEditor {
public:
    void drawShape(const Shape& shape) {
        shape.draw();  // 不需要关心具体类型
    }
};

// 可以轻易添加新的形状，而不需要修改使用 GraphicEditor 和 Shape 的代码
```

### L - 里氏替换原则 (Liskov Substitution Principle, LSP)

定义：**子类必须保持与父类行为的兼容**。
要点：
- 不修改代码的情况下，子类必须能够替代其父类而不会导致程序错误。

示例：

```cpp
// 不符合里氏替换原则的类
class Bird {
public:
    virtual void fly() { /* 飞行代码 */ }
};

class Ostrich : public Bird {
public:
    void fly() override {
        throw std::logic_error("Ostrich can't fly");
    }
};

// 符合里氏替换原则的类
class Bird {
public:
    virtual void move() { /* 移动代码 */ }
    virtual ~Bird() = default;
};

class Ostrich : public Bird {
public:
    void move() override {
        // 鸵鸟跑步而不是飞行
        std::cout << "Ostrich is running" << std::endl;
    }
};
```

### I - 接口隔离原则 (Interface Segregation Principle, ISP)

定义：**不应该强迫类依赖它们不需要的接口**。
要点：
- 应该将大接口分割成更小、更具体的接口。
- 避免"臃肿"接口，即包含许多方法的接口。

示例：

```cpp
// 不符合接口隔离原则的接口
class Worker {
public:
    virtual void work() = 0;
    virtual void eat() = 0;
    virtual ~Worker() = default;
};

class Robot : public Worker {
public:
    void work() override {
        std::cout << "Robot working" << std::endl;
    }
    
    // 机器人不需要吃饭，但被迫实现这个方法
    void eat() override { /* 机器人不需要吃饭 */ }
};

// 符合接口隔离原则的接口
class Workable {
public:
    virtual void work() = 0;
    virtual ~Workable() = default;
};

class Eatable {
public:
    virtual void eat() = 0;
    virtual ~Eatable() = default;
};

class Robot : public Workable {
public:
    void work() override {
        std::cout << "Robot working" << std::endl;
    }
};

class Human : public Workable, public Eatable {
public:
    void work() override {
        std::cout << "Human working" << std::endl;
    }
    
    void eat() override {
        std::cout << "Human eating" << std::endl;
    }
};
```

### D - 依赖倒置原则 (Dependency Inversion Principle, DIP)

定义：**高层模块不应该依赖低层模块，两者都应该依赖于抽象**。**抽象不应该依赖于细节，细节应该依赖于抽象**。
要点：
- 通过依赖抽象来解耦模块。
- 常通过使用接口和依赖注入来实现。

示例：

```cpp
// 不符合依赖倒置原则的类
class LightBulb {
public:
    void turnOn() {
        std::cout << "LightBulb is on" << std::endl;
    }

    void turnOff() {
        std::cout << "LightBulb is off" << std::endl;
    }
};

class Switch {
public:
    Switch(LightBulb& bulb) : bulb_(bulb) {}

    void operate() {
        bulb_.turnOn();
    }

private:
    LightBulb& bulb_;
};

// 符合依赖倒置原则的类
class Switchable {
public:
    virtual void turnOn() = 0;
    virtual void turnOff() = 0;
    virtual ~Switchable() = default;
};

class LightBulb : public Switchable {
public:
    void turnOn() override {
        std::cout << "LightBulb is on" << std::endl;
    }

    void turnOff() override {
        std::cout << "LightBulb is off" << std::endl;
    }
};

class Switch {
public:
    Switch(Switchable& device) : device_(device) {}

    void operate() {
        device_.turnOn();
    }

private:
    Switchable& device_;
};
```

### 应用 SOLID 原则的好处

- 提高代码的可读性和可维护性。
- 使系统更容易扩展和修改。
- 减少代码重复。
- 提高代码的重用性。
- 使代码更易于测试。

### 注意事项

- 过度应用这些原则可能导致代码过于复杂。
- 需要在实际应用中权衡利弊，根据具体情况适度应用。
- 这些原则更适合中大型项目，对于小型项目可能显得过度设计。

总之，SOLID 原则为创建健壮、灵活和可维护的软件提供了重要指导。合理应用这些原则可以显著提高代码质量和系统设计。

## 控制反转

控制反转（Inversion of Control，简称 IoC）是一种软件设计原则，它将程序流程的控制权从具体组件转移到外部容器或框架。让我们深入理解这个概念：

1. 基本定义：
   控制反转是一种设计原则，其中对象的创建、生命周期管理和对象间关系的控制权从**程序代码转移到外部容器或框架**。

2. "反转"的含义：
   传统方式：**程序<font color=blue>直接控制</font>流程和对象创建**。
   反转后：**程序变成被动的，由<font color=blue>框架或容器来控制</font>流程和对象创建**。

3. 主要目的：
   - 降低代码耦合度
   - 提高程序的可扩展性和可维护性
   - 支持更好的模块化设计

4. IoC 的主要形式：
   1. **依赖注入（Dependency Injection，DI）**：最常见的 IoC 实现方式，通过外部注入依赖。
   2. **服务定位器（Service Locator）**：通过一个中心化的注册表来管理和提供服务。
   3. **工厂模式**：使用工厂方法来创建对象，而不是直接使用 new 关键字。
   4. **模板方法模式**：基类定义算法骨架，子类提供具体实现。

5. 示例：

   ```cpp
   // 传统方式
   class Database {
   public:
       void connect() { /* ... */ }
   };

   class BusinessLogic {
       Database db;
   public:
       BusinessLogic() {
           db.connect();
       }
       void doSomething() { /* 使用db */ }
   };

   int main() {
       BusinessLogic logic;
       logic.doSomething();
   }

   // 使用 IoC 的方式
   class IDatabase {
   public:
       virtual void connect() = 0;
   };

   class BusinessLogic {
       IDatabase& db;
   public:
       BusinessLogic(IDatabase& database) : db(database) {}
       void doSomething() {
           db.connect();
           // 使用db
       }
   };

   // 在某个外部容器或框架中
   Database concreteDb;
   BusinessLogic logic(concreteDb);
   logic.doSomething();
   ```

   > 类名前加大写字母 `I`（如 `IDatabase`）表示这是一个接口，而不是具体实现。这样可以清晰区分接口与实现。
   > 但查到说不推荐：[Java - 为什么命名 interface 时不推荐添加 I 前缀？](https://blog.csdn.net/Dream_Weave/article/details/119907988)

6. IoC 容器：
   - 管理对象创建和生命周期
   - 处理依赖关系
   - 配置应用程序的组件

7. IoC 的优势：
   - 松耦合：组件之间的依赖更加灵活
   - 可测试性：更容易进行单元测试
   - 可维护性：更容易替换或升级组件
   - 模块化：支持更好的模块化设计

8. IoC 的应用场景：
   - 大型企业级应用
   - 框架设计
   - 插件架构

9. 常见的 IoC 框架/容器：
   - C++: Boost.DI
   - Java: Spring Framework
   - C#: .NET Core 依赖注入容器
   - Python: dependency_injector

10. 注意事项：
    - 可能增加代码的复杂性
    - 学习曲线可能较陡
    - 在小项目中可能显得过度设计

11. IoC 与其他原则的关系：
    - 与依赖倒置原则（DIP）密切相关
    - 有助于实现开闭原则（OCP）
    - 支持单一职责原则（SRP）

控制反转是一个强大的概念，它改变了我们思考和设计软件的方式。通过将控制权从具体组件转移到抽象框架，IoC 能够创建更加灵活、可维护和可测试的系统。然而，它也需要谨慎使用，因为过度使用可能导致不必要的复杂性。在实际应用中，需要根据项目的规模和需求来决定是否以及如何应用 IoC。

## 依赖注入

依赖注入（Dependency Injection，简称 DI）是一种设计模式和编程技术，用于**实现控制反转（Inversion of Control，IoC）原则**。
它的**核心思想**是将一个类所依赖的对象（即其依赖项）**从类的内部创建转移到外部提供**。
让我们深入了解依赖注入：

1. 基本概念：
   - **依赖**：一个类需要使用其他类来完成其功能。
   - **注入**：**从外部向类中**提供所需的依赖对象。

2. 主要目的：
   - 降低类之间的耦合度。
   - 提高代码的可测试性和可维护性。
   - 增加代码的灵活性和可重用性。

3. 依赖注入的方式：
   - 构造函数注入
   - Setter 注入/属性注入
   - 接口注入
   &nbsp;

   1. **构造函数注入**：
      通过构造函数参数提供依赖。

      ```cpp
      #include <iostream>
      
      // 接口
      class IDataAccess {
      public:
          virtual void fetchData() = 0;
      };
      
      // 具体实现
      class DataAccess : public IDataAccess {
      public:
          void fetchData() override {
              std::cout << "Fetching data from database." << std::endl;
          }
      };
      
      // 客户端类
      class Client {
      private:
          IDataAccess* dataAccess;
      public:
          Client(IDataAccess* dataAccess) : dataAccess(dataAccess) {}
          
          void doSomething() {
              dataAccess->fetchData();
          }
      };
      
      int main() {
          DataAccess dataAccess;
          Client client(&dataAccess);
          client.doSomething();
          return 0;
      }
      ```

   2. **Setter 注入/属性注入**：
      通过 setter 方法提供依赖。/ 通过公共属性或方法将依赖项赋值。

      ```cpp
      #include <iostream>
      
      // 接口
      class IDataAccess {
      public:
          virtual void fetchData() = 0;
      };
      
      // 具体实现
      class DataAccess : public IDataAccess {
      public:
          void fetchData() override {
              std::cout << "Fetching data from database." << std::endl;
          }
      };
      
      // 客户端类
      class Client {
      private:
          IDataAccess* dataAccess = nullptr;
      public:
          void setDatabase(IDataAccess* database) {
              dataAccess = database;
          }
      
          void doSomething() {
              if (dataAccess) {
                  dataAccess->fetchData();
              } else {
                  std::cout << "DataAccess not set." << std::endl;
              }
          }
      };
      
      int main() {
          DataAccess dataAccess;
          Client client;
          client.setDatabase(&dataAccess); // 属性注入
          client.doSomething();
          return 0;
      }
      ```

   3. **接口注入**：
      通过接口方法提供依赖。（把 public 的 setter 方法变成**纯虚类**接口）

      ```cpp
      #include <iostream>
      
      // 接口
      class IDataAccess {
      public:
          virtual void fetchData() = 0;
      };
      
      // 具体实现
      class DataAccess : public IDataAccess {
      public:
          void fetchData() override {
              std::cout << "Fetching data from database." << std::endl;
          }
      };
      
      // 依赖注入接口
      class IClient {
      public:
          virtual void setDataAccess(IDataAccess* dataAccess) = 0;
          virtual void doSomething() = 0;
      };
      
      // 客户端类
      class Client : public IClient {
      private:
          IDataAccess* dataAccess = nullptr;
      public:
          void setDataAccess(IDataAccess* dataAccess) override {
              this->dataAccess = dataAccess;
          }
      
          void doSomething() override {
              if (dataAccess) {
                  dataAccess->fetchData();
              } else {
                  std::cout << "DataAccess not set." << std::endl;
              }
          }
      };
      
      int main() {
          DataAccess dataAccess;
          Client client;
          client.setDataAccess(&dataAccess); // 接口注入
          client.doSomething();
          return 0;
      }
      ```

4. 依赖注入的优势：
   - 解耦：类不需要知道如何创建它们的依赖。
   - 可测试性：可以轻松注入 mock 对象进行单元测试。
   - 灵活性：可以在运行时或配置时更改依赖。
   - 可维护性：依赖关系明确，代码结构清晰。

5. 示例：

   ```cpp
   // 不使用依赖注入
   class UserService {
       MySqlDatabase db;  // 硬编码依赖
   public:
       void addUser(const User& user) {
           db.insert(user);
       }
   };

   // 使用依赖注入
   class UserService {
       IDatabase& db;
   public:
       UserService(IDatabase& database) : db(database) {}
       void addUser(const User& user) {
           db.insert(user);
       }
   };

   // 使用
   MySqlDatabase sqlDb;
   UserService service(sqlDb);
   ```

6. 依赖注入容器：
   - 在复杂系统中，通常**使用 DI 容器来管理依赖**。
   - 容器负责创建、配置和提供所需的对象。

   ```cpp
   DIContainer container;
   container.register<IDatabase, MySqlDatabase>();
   container.register<UserService>();
   
   auto service = container.resolve<UserService>();
   ```

7. 注意事项：
   过度使用可能导致代码复杂性增加。
   在小型项目中可能显得过度设计。
   需要权衡灵活性和代码的直观性。

8. 与其他原则的关系：
   依赖倒置原则（DIP）的一种实现方式。
   有助于实现单一职责原则（SRP）和开闭原则（OCP）。

9.  在不同语言中的应用：
   C++：通常通过手动实现或使用如 Boost.DI 等库。
   Java：Spring 框架是最著名的 DI 容器之一。
   C#：.NET Core 提供内建的 DI 容器。

依赖注入是一种强大的技术，能够显著提高代码质量和系统设计。但它也需要一定的学习曲线和经验才能恰当使用。在实践中，需要根据项目规模和复杂度来决定是否以及如何使用依赖注入。



## 三者关系


依赖倒置（Dependency Inversion Principle, DIP）、依赖注入（Dependency Injection）、控制反转（Inversion of Control, IoC）是软件设计中的三个重要概念，它们之间有着紧密的联系。

1. 依赖倒置（DIP）
依赖倒置原则是面向对象设计的**五个原则之一**，它强调高层模块不应依赖于低层模块，两者都应依赖于抽象（接口或抽象类）。此外，抽象不应依赖于细节，细节应依赖于抽象。通过遵循这一原则，可以减少模块之间的依赖关系，使得系统更易于扩展和维护。

2. 控制反转（IoC）
控制反转是**一个设计原则**，强调将控制权从程序的主逻辑中转移出去。传统的编程模式中，程序通过创建和管理对象的生命周期来控制流程，而控制反转则是将这种控制权交给外部框架或容器。这样可以使程序更具可扩展性和可测试性。

3. 依赖注入（DI）
依赖注入是一种**实现控制反转的方式**。它通过将对象所依赖的组件（依赖）通过构造函数、方法或属性注入的方式提供给对象，而不是由对象自己创建。这样，依赖关系在运行时被注入，而不是在编译时硬编码。这使得组件之间的耦合度降低，增强了灵活性和可测试性。


**三者之间的关系**
控制反转是一个广泛的概念，包含了多种实现方式，依赖注入就是其中一种。
依赖注入是实现控制反转的一种具体方法。
依赖倒置原则提供了一个指导思想，鼓励使用抽象来减少模块间的依赖，从而为依赖注入和控制反转提供了理论基础。


# 行为模式

## 策略模式

### 策略模式简介

**策略模式**（Strategy Pattern）是一种行为型设计模式，它定义了一系列算法（策略），并将每个算法封装在独立的类中，使得它们可以相互替换。策略模式的核心思想是通过将**算法**从使用它的代码中**分离**出来，**使得算法可以独立于其上下文自由变化**。

策略模式的主要组成部分包括：

1. **策略接口（Strategy Interface）**：定义算法的公共接口。
2. **具体策略类（Concrete Strategies）**：实现策略接口的不同算法。
3. **上下文类（Context Class）**：使用策略对象的类，它会持有一个策略对象，并通过该对象调用算法。

### 策略模式的优点

- **开放/关闭原则**：可以轻松增加新算法，而无需修改现有的上下文代码。
- **代码复用**：将算法的实现与使用分离，便于代码复用。
- **简化条件判断**：通过将不同算法封装成策略类，避免了大量的条件分支判断（如 `if-else` 或 `switch-case`）。

### 策略模式的典型实现方式

- 使用**接口和类**的实现（面向对象的实现）
- 使用**函数指针**实现策略模式
- 使用 `std::function` 和 `lambda` 表达式
- 使用策略工厂

1. 使用接口和类的实现（面向对象的实现）

   这是策略模式最常见的实现方式，通过创建一个策略接口，定义算法的公共方法，然后创建不同的具体策略类来实现不同的算法。

   **示例**：C++

   ```cpp
   #include <iostream>
   #include <memory>

   // 策略接口
   class Strategy {
   public:
       virtual void execute() const = 0; // 纯虚函数
       virtual ~Strategy() {}
   };

   // 具体策略 A
   class ConcreteStrategyA : public Strategy {
   public:
       void execute() const override {
           std::cout << "Executing Strategy A" << std::endl;
       }
   };

   // 具体策略 B
   class ConcreteStrategyB : public Strategy {
   public:
       void execute() const override {
           std::cout << "Executing Strategy B" << std::endl;
       }
   };

   // 上下文类
   class Context {
   private:
       std::unique_ptr<Strategy> strategy;  // 持有策略的指针
   public:
       void setStrategy(std::unique_ptr<Strategy> newStrategy) {
           strategy = std::move(newStrategy);
       }
       
       void executeStrategy() const {
           if (strategy) {
               strategy->execute();
           }
       }
   };

   int main() {
       Context context;

       // 使用策略A
       context.setStrategy(std::make_unique<ConcreteStrategyA>());
       context.executeStrategy();

       // 切换到策略B
       context.setStrategy(std::make_unique<ConcreteStrategyB>());
       context.executeStrategy();

       return 0;
   }
   ```

2. 使用函数指针实现策略模式

   在C++中，策略模式也可以通过**函数指针**来实现。这种方式的优点是可以减少类的创建，适合简单的场景。
   如有需要，可以**创建 key->function 的 map**。

   **示例**：C++ 函数指针

   ```cpp
   #include <iostream>

   // 策略函数
   void strategyA() {
       std::cout << "Executing Strategy A" << std::endl;
   }

   void strategyB() {
       std::cout << "Executing Strategy B" << std::endl;
   }

   // 上下文类
   class Context {
   private:
       void (*strategy)();  // 函数指针
   public:
       void setStrategy(void (*newStrategy)()) {
           strategy = newStrategy;
       }
       
       void executeStrategy() const {
           if (strategy) {
               strategy();
           }
       }
   };

   int main() {
       Context context;

       // 使用策略A
       context.setStrategy(strategyA);
       context.executeStrategy();

       // 切换到策略B
       context.setStrategy(strategyB);
       context.executeStrategy();

       return 0;
   }
   ```

3. 使用 `std::function` 和 `lambda` 表达式

   在C++11及之后版本中，使用 `std::function` 和 `lambda` 表达式来实现策略模式变得更加灵活，可以动态定义策略，并且适合传递更复杂的函数对象。

   **示例**：C++ 使用 `std::function` 和 `lambda`

   ```cpp
   #include <iostream>
   #include <functional>

   class Context {
   private:
       std::function<void()> strategy;  // 使用 std::function 存储策略
   public:
       void setStrategy(std::function<void()> newStrategy) {
           strategy = newStrategy;
       }
       
       void executeStrategy() const {
           if (strategy) {
               strategy();
           }
       }
   };

   int main() {
       Context context;

       // 使用 lambda 表达式作为策略A
       context.setStrategy([]() {
           std::cout << "Executing Strategy A" << std::endl;
       });
       context.executeStrategy();

       // 使用 lambda 表达式作为策略B
       context.setStrategy([]() {
           std::cout << "Executing Strategy B" << std::endl;
       });
       context.executeStrategy();

       return 0;
   }
   ```

4. 使用策略工厂

   策略模式可以结合**工厂模式**来动态生成策略类的实例。工厂模式可以将策略的创建逻辑集中到一个地方，使得代码更加灵活。

   **示例**：C++ 策略工厂

   ```cpp
   #include <iostream>
   #include <memory>
   #include <unordered_map>
   #include <functional>

   // 策略接口
   class Strategy {
   public:
       virtual void execute() const = 0;
       virtual ~Strategy() {}
   };

   // 具体策略 A
   class ConcreteStrategyA : public Strategy {
   public:
       void execute() const override {
           std::cout << "Executing Strategy A" << std::endl;
       }
   };

   // 具体策略 B
   class ConcreteStrategyB : public Strategy {
   public:
       void execute() const override {
           std::cout << "Executing Strategy B" << std::endl;
       }
   };

   // 策略工厂
   class StrategyFactory {
   public:
       static std::unique_ptr<Strategy> createStrategy(const std::string& type) {
           if (type == "A") {
               return std::make_unique<ConcreteStrategyA>();
           } else if (type == "B") {
               return std::make_unique<ConcreteStrategyB>();
           } else {
               return nullptr;
           }
       }
   };

   // 上下文类
   class Context {
   private:
       std::unique_ptr<Strategy> strategy;
   public:
       void setStrategy(std::unique_ptr<Strategy> newStrategy) {
           strategy = std::move(newStrategy);
       }
       
       void executeStrategy() const {
           if (strategy) {
               strategy->execute();
           }
       }
   };

   int main() {
       Context context;

       // 从工厂获取策略A并执行
       context.setStrategy(StrategyFactory::createStrategy("A"));
       context.executeStrategy();

       // 从工厂获取策略B并执行
       context.setStrategy(StrategyFactory::createStrategy("B"));
       context.executeStrategy();

       return 0;
   }
   ```

### 总结

策略模式是解决在运行时动态选择算法的常用设计模式。通过不同的实现方式，我们可以根据需求选择合适的方式来应用策略模式：

- 面向对象的方式适合复杂系统，使用继承实现不同策略。
- 函数指针、`std::function` 和 lambda 更加轻量，适合灵活的函数传递场景。
- 策略工厂可以与策略模式结合，进一步解耦创建策略的逻辑。

不同的实现方式可以适应不同的应用场景，增强代码的可扩展性和灵活性。
