# 重构

## 圈复杂度

[详解圈复杂度](https://kaelzhang81.github.io/2017/06/18/%E8%AF%A6%E8%A7%A3%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6/)

1. 圈复杂度概念

   **圈复杂度（Cyclomatic complexity，简写 CC）** 也称为条件复杂度，是一种代码复杂度的衡量标准。由托马斯·J·麦凯布（Thomas J. McCabe, Sr.）于 1976 年提出，用来表示程序的复杂度，其**符号为 VG 或是 M**。它可以用来衡量一个模块判定结构的复杂程度，数量上表现为独立现行路径条数，也可理解为覆盖所有的可能情况最少使用的测试用例数。圈复杂度大说明程序代码的判断逻辑复杂，可能质量低且难于测试和 维护。程序的可能错误和高的圈复杂度有着很大关系。

2. 圈复杂度计算方法

   - **点边计算法**

     ![name basic flow graph](https://kaelzhang81.github.io/img/in-post/cyclomatic-complexity/%E7%82%B9%E8%BE%B9%E8%AE%A1%E7%AE%97%E6%B3%95.jpg)

     圈复杂度的计算方法很简单，计算公式为：

     > V(G) = E - N + 2

     其中，e 表示控制流图中边的数量，n 表示控制流图中节点的数量。

     几个节点通过边连接。下面是典型的控制流程，如 if-else，While，until 和正常的流程顺序：

     ![name basic flow graph](https://kaelzhang81.github.io/img/in-post/cyclomatic-complexity/%E5%9F%BA%E7%A1%80%E9%80%BB%E8%BE%91.png)

   - **节点判定法**

     其实，圈复杂度的计算还有更直观的方法，因为圈复杂度所反映的是“判定条件”的数量，所以圈复杂度实际上就是**等于判定节点的数量再加上 1**，也即控制流图的区域数，对应的计算公式为：

     > V (G) = P + 1

     其中 P 为判定节点数，判定节点举例：

     1. if 语句
     2. while 语句
     3. for 语句
     4. case 语句
     5. catch 语句
     6. and 和 or 布尔操作
     7. ?:三元运算符

     对于多分支的 CASE 结构或 IF-ELSEIF-ELSE 结构，统计判定节点的个数时需要特别注意一点，要求必须统计全部实际的判定节点数，也即**每个 ELSEIF 语句，以及每个 CASE 语句，都应该算为一个判定节点**。

   判定节点在模块的控制流图中很容易被识别出来，所以：

   - 针对程序的控制流图计算圈复杂度 V(G)时，一般采用点边计算法，也即 V(G)=e-n+2；
   - 而针对模块的控制流图时，可以直接使用统计判定节点数，这样更为简单。

3. **练习**

   ```cpp
   U32 find(string match)
   {
       for (auto var : list) {
           if (var == match && from != INVALID_U32)
               return INVALID_U32;
       }
       // match step1
       if (session == getName() && key == getKey()) {
           for (auto &kv : Map) {
               if (kv.second == last && match == kv.first) {
                   return last;
               }
           }
       }
       // match step2
       auto var = Map.find(match);
       if (var != Map.end() && (from != var->second))
           return var->second;

       // match step3
       for (auto var : Map) {
           if ((var.first, match) && from != var.second) {
               return var.second;
           }
       }
       return INVALID_U32;
   };
   ```

   其圈复杂度为：V(G) = 1(for) + 2(if) + 2(if) + 1(for) + 2(if) + 2(if) + 1(for) + 2(if) + 1= 14

4. **圈复杂度和软件质量**

   | 圈复杂度 | 代码状况     | 可测性 | 维护成本 |
   | :------- | :----------- | :----- | :------- |
   | 1-10     | 清晰、结构化 | 高     | 低       |
   | 10-20    | 复杂         | 中     | 中       |
   | 20-30    | 非常复杂     | 低     | 高       |
   | >30      | 不可读       | 不可测 | 非常高   |

5. **降低圈复杂度的方法**

   参见：[详解圈复杂度](https://kaelzhang81.github.io/2017/06/18/%E8%AF%A6%E8%A7%A3%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6/)

# 代码分析工具

## InFusion

[InFusion 错误类型分析](https://www.cnblogs.com/jiyuqi/p/3492575.html)

# InFusion 错误类型分析

## 1 God Class

### 1.1 特征

上帝类通常过多的操纵其他类的数据，从而破坏了类的封装性。上帝类从其他类中获得功能，同时增加了自身的耦合性，通常会导致自己具有规模过大和较高的复杂度。

判断一个上帝类的标准有：

![img](https://images0.cnblogs.com/blog/531894/201312/26154509-728f45cf46fb4d389fcbe76b00dba471.png)

1. CPFD (Capsules Providing Foreign Data) 从多个不相关类（模块）中引用数据
2. WOC (Weighted Operation Count) 类的所有函数的圈复杂度之和超过 65
3. TCC (Tight Capsule Cohesion) TCC < 1/3 类需要具有低内聚的特性（类中直接相关的方法与全部方法之比小于 1/3），也就是较少的 private 方法
4. 需要同时满足以上条件才可以被认定为上帝类

> 低内聚：是去看类中的方法是否共同访问类的某个属性，如果两个方法都访问类的某个属性，则认为它们关系紧密，否则就没关系，然后计算有关系方法与无关系方法的比例。

### 1.2 修改

破坏 CPFD, WOC, TCC 中的一个。
